{"version":3,"sources":["components/InputRow.js","components/Options.js","modules/main.js","modules/plot.js","App.js","reportWebVitals.js","index.js"],"names":["InputRow","props","divId","id","className","htmlFor","name","type","required","pattern","autoComplete","onChange","e","sendData","target","checked","value","Options","DIM","hjOptionsList","map","data","saOptionsList","geneticOptionsList","swarmOptionsList","tabuOptionsList","saOptions","hjOptions","geneticOptions","swarmOptions","tabuOptions","method","math","create","all","EPS","MethodOutput","checkedPoints","functionIterations","xMin","fMin","functionValues","this","CheckStringVector","stringVector","re","r","match","forEach","element","error","parseStartPoint","startPointString","lb","ub","startPoint","length","i","parseFloat","initializePoint","arr","x","x1","x2","x3","x4","x5","x6","x7","x8","x9","property","simulatedAnnealing","T","N","f","C","beta","getProbability","df","Math","exp","tossCoin","p","random","myRand","density","nx","norm","sqrt","PI","c","X","Array","Z","Object","values","slice","evaluate","dx","k","y","addition","key","assign","push","getValuesForPlot","objectiveFunction","lowerBound","upperBound","getNumbersBetween","range","step","abs","idx","Y","Xi","point","j","sort","a","b","coordsForContour","labelsList","checkedPointsT","createTree","objectiveFunctionString","node","parse","constants","Set","functions","symbols","traverse","isSymbolNode","add","isFunctionNode","has","setA","setB","difference","elem","delete","union","subtraction","multiplication","hookeJeeves","eps","deltaVector","lambda","alpha","yNext","xNext","loop1","loop2","filter","item","DoubleSidedMap","keys","index","findIndex","it","getRandomInt","min","max","ceil","floor","getMinimum","population","minValue","Number","MAX_SAFE_INTEGER","v","idxMin","getMaximum","maxValue","MIN_SAFE_INTEGER","idxMax","arrayContainsIn","mainArr","count","startOptimization","selectedMethodString","params","isNaN","t","replace","returned","size","symbols_sorted","from","symbols_new","dict","Map","set","transform","SymbolNode","get","console","log","toString","compile","parseFunction","allowModification","mod","undefined","pointsList","bestResult","minF","totalFunctionIterations","start","Date","now","curF","methodTime","returnedFromMethod","maxIter","parseInt","maxIterations","startT","initialTemperature","tMax","m","li","numbers","greys","grey","buildGrey","mapGrey","Creature","genotype","getValue","decode","g","gString","len","gS1","gString_","RegExp","parents","parentA","parentB","pA","pB","pA1","pA2","pB1","gsch1","gsch2","code","fenotype","chromosom","priznak","h","getByKey","genotypeDecoded","gamma","getByValue","M","P","xk","step2","probabilityInterval","masterLoop","coin","childCandidate","containsIn","crossover","sch1","sch2","mutate","geneticBinary","np","ni","omega","K","niVector","NImin","NImax","position","bestPosition","speed","bestPositionOfNeighbors","first","second","third","multiply","r1","r2","subtract","posValue","xArr","neighbors","minValueOfNeighbors","changePosition","particleSwarm","L","maxEdge","edge","delta","Rtr","Rstr","L_","Nmin","Mmin","TabuPoint","coordinate","Ir","If","mValue","Region","phi","getCentersOfTouchedSemiTabuRegions","tabuList","centers","lp","getMaxDistance","Dmax","getDirection","t_","d","sign","getStep","delta_","adaptiveSearch","sumOfDeltaF","fx","w","u","zer","zeros","uNum","uDen","divide","sigma","rp","newPoint","_data","fy","updateTabuList","tabuPoint","remove","updateVisitedRegionList","visitedRegionList","isRegionTouched","newRegion","points","Mr","Mf","Ir_","splice","sum","directionVector","fxNext","z","returnedfMin","tabuSearch","getPlot","scatterData","line","color","text","textposition","mode","textfont","hoverinfo","contourData","scatterMinData","marker","symbol","contours","end","margin","hovermode","showlegend","parametersList","Plot","createPlotlyComponent","Plotly","rowsData","methodFullName","optionsData","App","useState","layout","plotState","setPlotState","results","setResults","setMethod","inputRowList","row","optionsList","event","selectedOptions","onSubmit","preventDefault","isFinite","NaN","plotData","newPlotState","s","toFixed","stringMinVector","newResults","alert","onInitialized","figure","onUpdate","readOnly","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.2a3dfd44.chunk.js","sourcesContent":["import \"../InputRow.css\";\r\n\r\nfunction InputRow (props) {\r\n    function handleChange(e) {\r\n        if (props.type===\"checkbox\"){\r\n            props.sendData(props.id,e.target.checked);\r\n        }\r\n        else{\r\n            props.sendData(props.id,e.target.value);\r\n        }\r\n    }\r\n    const divId=props.id+\"-container\";\r\n    return (\r\n        <div id={divId}>\r\n            <label className=\"row-label\" htmlFor={props.id}>{props.name}</label>\r\n            <input className=\"row-input\" id={props.id} type={props.type} required={props.required} pattern={props.pattern} \r\n            autoComplete=\"off\" onChange={handleChange}/>\r\n        </div>\r\n    );\r\n}\r\nexport default InputRow;","import InputRow from \"../components/InputRow\";\r\nfunction Options(props) {\r\n    const saOptionsData = [\r\n        { id: \"startPoint\", name: \"Точка старта\", required: \"required\", pattern: \"[pie\\\\d .,;\\\\[\\\\]-]+\" },\r\n        { id: \"maxIterations\", name: \"Количество итераций\", required: \"required\", pattern: \"[\\\\d. ]+\" },\r\n        { id: \"initialTemperature\", name: \"Начальная температура (>0)\", required: \"required\", pattern: \"[\\\\d .]+\" },\r\n        { id: \"c\", name: \"Пар-р распределения Больцмана (>0)\", required: \"required\", pattern: \"[\\\\d .]+\" },\r\n        { id: \"beta\", name: \"Пар-р уменьшения температуры [0.8;0.99]\", required: \"required\", pattern: \"[\\\\d .]+\" }\r\n    ];\r\n    const hjOptionsData = [\r\n        { id: \"startPoint\", name: \"Точка старта\", required: \"required\", pattern: \"[pie\\\\d .,;\\\\[\\\\]-]+\" },\r\n        { id: \"deltaVector\", name: \"Вектор длин шагов\", required: \"required\", pattern: \"[pie\\\\d .,;\\\\[\\\\]-]+\" },\r\n        { id: \"lambda\", name: \"Множитель шага (>0)\", required: \"required\", pattern: \"[\\\\d. ]+\" },\r\n        { id: \"alpha\", name: \"Коэф.уменьшения шага (>1)\", required: \"required\", pattern: \"[\\\\d. ]+\" },\r\n        { id: \"eps\", name: \"Значение для остановки алгоритма (>0)\", required: \"required\", pattern: \"[\\\\d. ]+\" },\r\n        { id: \"mod\", name: \"Применить метод мультистарта\", type:\"checkbox\", required: \"\", pattern: \"\" }\r\n    ];\r\n    const geneticOptionsData = [\r\n        { id: \"maxIterations\", name: \"Количество итераций\",type:\"text\", required: \"required\", pattern: \"[\\\\d. ]+\" },\r\n        { id: \"m\", name: \"Объём популяции\",type:\"text\", required: \"required\", pattern: \"[\\\\d. ]+\" },\r\n        { id: \"li\", name: \"Длина кодирования гена (<15)\",type:\"text\", required: \"required\", pattern: \"[\\\\d. ]+\" }\r\n    ];\r\n    const swarmOptionsData = [\r\n        { id: \"maxIterations\", name: \"Количество итераций\",type:\"text\", required: \"required\", pattern: \"[\\\\d. ]+\" },\r\n        { id: \"np\", name: \"Количество частиц в стае\",type:\"text\", required: \"required\", pattern: \"[\\\\d. ]+\" },\r\n        { id: \"ni\", name: \"Мин. и макс. число соседей\",type:\"text\", required: \"required\", pattern: \"[\\\\d ,;\\\\[\\\\]]+\" },\r\n        { id: \"omega\", name: \"Весовой коэф. (0.01;0.7)\",type:\"text\", required: \"required\", pattern: \"[\\\\d. ]+\" },\r\n        { id: \"alpha\", name: \"Альфа (для вычисления скорости)\",type:\"text\", required: \"required\", pattern: \"[\\\\d. ]+\" },\r\n        { id: \"beta\", name: \"Бета (для вычисления скорости)\",type:\"text\", required: \"required\", pattern: \"[\\\\d. ]+\" }\r\n    ];\r\n    const tabuOptionsData = [\r\n        { id: \"M\", name: \"Количество попыток иссл. поиска\",type:\"text\", required: \"required\", pattern: \"[\\\\d. ]+\" },\r\n        { id: \"N\", name: \"Количество попыток иссл.-пер. поиска\",type:\"text\", required: \"required\", pattern: \"[\\\\d. ]+\" },\r\n        { id: \"L\", name: \"Количество записей в табу-листе\", type:\"text\", required: \"required\", pattern: \"[\\\\d. ]+\" },\r\n        { id: \"mod\", name: \"Использовать метод имитации отжига\", type:\"checkbox\", required: \"\", pattern: \"\" }\r\n    ];\r\n\r\n    const hjOptionsList = hjOptionsData.map(data =>\r\n        <InputRow key={data.id} id={data.id} name={data.name} pattern={data.pattern} type={data.type} required={data.required} sendData={props.sendData} />);\r\n    const saOptionsList = saOptionsData.map(data =>\r\n        <InputRow key={data.id} id={data.id} name={data.name} pattern={data.pattern} type={data.type} required={data.required} sendData={props.sendData} />);\r\n    const geneticOptionsList = geneticOptionsData.map(data =>\r\n        <InputRow key={data.id} id={data.id} name={data.name} pattern={data.pattern} type={data.type} required={data.required} sendData={props.sendData} />);\r\n    const swarmOptionsList = swarmOptionsData.map(data =>\r\n        <InputRow key={data.id} id={data.id} name={data.name} pattern={data.pattern} type={data.type} required={data.required} sendData={props.sendData} />);\r\n    const tabuOptionsList = tabuOptionsData.map(data =>\r\n        <InputRow key={data.id} id={data.id} name={data.name} pattern={data.pattern} type={data.type} required={data.required} sendData={props.sendData} />);\r\n    const saOptions = (\r\n        <div className=\"options section\">\r\n            {saOptionsList}\r\n        </div>\r\n    );\r\n    const hjOptions = (\r\n        <div className=\"options section\">\r\n            {hjOptionsList}\r\n        </div>\r\n    );\r\n    const geneticOptions = (\r\n        <div className=\"options section\">\r\n            {geneticOptionsList}\r\n        </div>\r\n    );\r\n    const swarmOptions = (\r\n        <div className=\"options section\">\r\n            {swarmOptionsList}\r\n        </div>\r\n    );\r\n    const tabuOptions = (\r\n        <div className=\"options section\">\r\n            {tabuOptionsList}\r\n        </div>\r\n    );\r\n    switch (props.method) {\r\n        case \"SA\":\r\n            return saOptions;\r\n        case \"HJ\":\r\n            return hjOptions;\r\n        case \"Genetic\":\r\n            return geneticOptions;\r\n        case \"Swarm\":\r\n            return swarmOptions;\r\n        case \"Tabu\":\r\n            return tabuOptions;\r\n        default:\r\n            break;\r\n    }\r\n}\r\nexport default Options;","import { create, all } from \"mathjs\";\r\nconst math = create({\r\n    all\r\n});\r\nvar DIM;\r\nconst EPS = 1e-8;\r\n//[checkedPoints, functionIterations, xMin, fMin, functionValues];\r\nclass MethodOutput{\r\n    constructor(checkedPoints, functionIterations, xMin, fMin, functionValues){\r\n        this.checkedPoints=checkedPoints;\r\n        this.functionIterations=functionIterations;\r\n        this.xMin=xMin; \r\n        this.fMin=fMin; \r\n        this.functionValues=functionValues;\r\n    }\r\n}\r\nfunction CheckStringVector(stringVector) {\r\n    try {\r\n      let re = /[\\w.]+/g;\r\n      let r = stringVector.match(re);\r\n      if (r === null) { throw \"Пустая строка\"; }\r\n      re = /^\\d+$|^\\d+\\.\\d+$/;\r\n      r.forEach(element => {\r\n        if (element.match(re) === null) { throw \"Слишком много точек\"; }\r\n      });\r\n    }\r\n    catch (error) {\r\n      return error;\r\n    }\r\n    return 0;\r\n  }\r\nfunction parseStartPoint(startPointString,lb,ub) {\r\n    let re = /[\\w.-]+/g;\r\n    let startPoint = startPointString.match(re);\r\n    if (startPoint.length !== DIM) {\r\n        return -2;\r\n    }\r\n    for (let i = 0; i < DIM; i++) {\r\n        startPoint[i] = parseFloat(startPoint[i]);\r\n        if (startPoint[i] < lb[i]){\r\n            startPoint[i]=lb[i];\r\n        }\r\n        else {\r\n            if (startPoint[i] > ub[i]){\r\n            startPoint[i]=ub[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    return startPoint;\r\n}\r\nfunction initializePoint(arr) {\r\n    let x = { x1: 0, x2: 0, x3: 0, x4: 0, x5: 0, x6: 0, x7: 0, x8: 0, x9: 0 };\r\n    let i = 0;\r\n    for (const property in x) {\r\n        x[property] = arr[i++];\r\n        if (i === DIM) {\r\n            break;\r\n        }\r\n    }\r\n    return x;\r\n}\r\n\r\n\r\nfunction simulatedAnnealing(T, N, x, f, C, beta, lb, ub) {\r\n    function getProbability(df, C, T) { return Math.exp(-df / C / T); }\r\n    function tossCoin(p) { return Math.random() < p; }\r\n\r\n    function myRand(T) {\r\n        function density(x, T) {\r\n            let nx = math.norm(x);\r\n            return Math.exp(-(nx ** 2 / 2 / T)) / (Math.sqrt(2 * Math.PI * T)) ** DIM;\r\n        }\r\n        let a = -10, b = 10;\r\n        let N = 1000;\r\n        let c = density(0, T);\r\n        let X = new Array(2), Z = new Array(2);\r\n        for (let i = 0; i < N; i++) {\r\n            X[0] = Math.random();\r\n            X[1] = Math.random();\r\n            Z[0] = a + X[0] * (b - a);\r\n            Z[1] = X[1] * c;\r\n            if (Z[1] < density(Z[0])) {\r\n                return Z[0];\r\n            }\r\n        }\r\n        return Z[0];\r\n    }\r\n    x = initializePoint(x);\r\n    let checkedPoints = [Object.values(x).slice(0, DIM)];\r\n    let functionValues = [f.evaluate(x)];\r\n    let dx = new Array(DIM);\r\n    let functionIterations = 0;\r\n    for (let k = 0; k < N - 1; k++) {\r\n        for (let i = 0; i < DIM; i++) {\r\n            dx[i] = myRand(T);\r\n        }\r\n        let dx_ = initializePoint(dx);\r\n        let y = addition(x, dx_);\r\n        let i = 0;\r\n        for (const key in y) {\r\n            if (y[key] > ub[i]) {\r\n                y[key] = ub[i];\r\n            }\r\n            else {\r\n                if (y[key] < lb[i]) {\r\n                    y[key] = lb[i];\r\n                }\r\n            }\r\n        }\r\n        let df = f.evaluate(y) - f.evaluate(x);\r\n        functionIterations += 2;\r\n        if (df < 0) {\r\n            x = Object.assign({}, y);\r\n            checkedPoints.push(Object.values(x).slice(0, DIM));\r\n            functionValues.push(f.evaluate(x));\r\n        }\r\n        else {\r\n            let p = getProbability(df, C, T);\r\n            if (tossCoin(p) === true) {\r\n                x = Object.assign({}, y);\r\n                checkedPoints.push(Object.values(x).slice(0, DIM));\r\n                functionValues.push(f.evaluate(x));\r\n            }\r\n        }\r\n        T *= beta;\r\n    }\r\n    let xMin = Object.assign({}, x);\r\n    let fMin = f.evaluate(xMin);\r\n    let methodOutput= new MethodOutput(checkedPoints, functionIterations, xMin, fMin, functionValues)\r\n    return methodOutput;\r\n}\r\n\r\nfunction coordsForContour(lowerBound, upperBound, objectiveFunction, checkedPoints) {\r\n    function getNumbersBetween(lowerBound, upperBound, N) {\r\n        var range = new Array(N);\r\n        var step = Math.abs((upperBound - lowerBound)) / N;\r\n        var idx = 0;\r\n        for (let i = lowerBound; i < upperBound - EPS; i += step) {\r\n            range[idx] = i;\r\n            idx++;\r\n        }\r\n        return range;\r\n    }\r\n    var N = 100; //quantity\r\n    var X = [];\r\n    var Y;\r\n    for (let i = 0; i < DIM; i++) {\r\n        let Xi = getNumbersBetween(lowerBound[i], upperBound[i], N);\r\n        X.push(Xi);\r\n    }\r\n\r\n    for (const point of checkedPoints) {\r\n        for (let j = 0; j < DIM; j++) {\r\n            X[j].push(point[j]);\r\n        }\r\n    }\r\n    for (let i = 0; i < DIM; i++) {\r\n        X[i].sort(function (a, b) {\r\n            return a - b;\r\n        });\r\n    }\r\n    N += checkedPoints.length;\r\n    if (DIM === 2) {\r\n        Y = new Array(N);\r\n        for (let i = 0; i < N; i++) {\r\n            Y[i] = new Array(N);\r\n        }\r\n        for (let i = 0; i < N; i++) {\r\n            for (let j = 0; j < N; j++) {\r\n                let x = { x1: X[0][i], x2: X[1][j] };\r\n                Y[j][i] = objectiveFunction.evaluate(x);//rows - Yaxis, cols - Xaxis in plotly contour\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        Y = [];\r\n        for (let i = 0; i < N; i++) {\r\n            let x = { x1: X[0][i] };\r\n            Y.push(objectiveFunction.evaluate(x));//rows - Yaxis, cols - Xaxis in plotly contour\r\n        }\r\n    }\r\n    return [X, Y];\r\n}\r\n\r\nfunction getValuesForPlot(objectiveFunction, lowerBound, upperBound, checkedPoints) {\r\n    let [X, Y] = coordsForContour(lowerBound, upperBound, objectiveFunction, checkedPoints);\r\n    let labelsList = [];\r\n    for (let i = 0; i <= checkedPoints.length; i++) {\r\n        labelsList.push(i);\r\n    }\r\n    //checkedPoints transposed\r\n    var checkedPointsT = [];\r\n    for (let i = 0; i < DIM; i++) {\r\n        checkedPointsT[i] = new Array(checkedPoints.length);\r\n    }\r\n\r\n    for (let i = 0; i < checkedPoints.length; i++) {\r\n        let point = checkedPoints[i];\r\n        for (let j = 0; j < DIM; j++) {\r\n            checkedPointsT[j][i] = point[j];\r\n        }\r\n    }\r\n    //compute function values on the search line\r\n    if (DIM === 1) {\r\n        checkedPointsT[1] = new Array(checkedPointsT[0].length);\r\n        for (let i = 0; i < checkedPointsT[0].length; i++) {\r\n            checkedPointsT[1][i] = objectiveFunction.evaluate({ x1: checkedPointsT[0][i] });\r\n        }\r\n    }\r\n    return [X, Y, checkedPointsT, labelsList];\r\n}\r\n//difference = set - subset\r\nfunction difference(setA, setB) {\r\n    let difference = new Set(setA);\r\n    for (let elem of setB) {\r\n        if (difference.has(elem)) {\r\n            difference.delete(elem);\r\n        }\r\n    }\r\n    return difference;\r\n}\r\nfunction union(setA, setB) {\r\n    let union = new Set(setA)\r\n    for (let elem of setB) {\r\n        union.add(elem)\r\n    }\r\n    return union\r\n}\r\n\r\nfunction createTree(objectiveFunctionString) {\r\n    var node = math.parse(objectiveFunctionString);\r\n    var constants = new Set(['pi', 'e', 'E', 'i', 'PI']);\r\n    var functions = new Set(['sin', 'cos', 'tan', 'cot', 'exp', 'abs', 'sqrt', 'sign', 'log',\r\n        'log10', 'log2', 'nthRoot', 'acos', 'acot', 'asin', 'atan', 'sec', 'norm']);\r\n    var symbols = new Set();\r\n    node.traverse(function (node) {\r\n        if (node.isSymbolNode) {\r\n            symbols.add(node.name);\r\n        }\r\n        else if (node.isFunctionNode && functions.has(node.name)) {\r\n            functions.add(node.name);\r\n        }\r\n    });\r\n    symbols = difference(symbols, union(constants, functions));\r\n    return [node, symbols];\r\n}\r\n\r\nfunction parseFunction(objectiveFunctionString, DIM) {\r\n    let c = new Set(['pi', 'e', 'E', 'i', 'PI', 'sin', 'cos', 'tan', 'cot', 'exp', 'abs', 'sqrt', 'sign', 'log',\r\n        'log10', 'log2', 'nthRoot', 'acos', 'acot', 'asin', 'atan', 'sec', 'norm']);\r\n    try {\r\n        //mapping \"(\" -> \"*(\"\r\n        let re = /[\\w.]+(?=\\()/g;\r\n        let r = objectiveFunctionString.match(re);\r\n        if (r !== null) {\r\n            r = r.filter(item => !c.has(item));\r\n            r.forEach(t => {\r\n                objectiveFunctionString = objectiveFunctionString.replace(t, t + '*');\r\n            });\r\n        }\r\n        let returned = createTree(objectiveFunctionString);\r\n        let node = returned[0];\r\n        let symbols = returned[1];\r\n        if (symbols.size !== DIM) { throw \"Несоответствие размерностей целевой функции и стартовой точки.\"; }\r\n        //renaming variables to the hardcoded names\r\n        let symbols_sorted = Array.from(symbols).sort();\r\n        let symbols_new = ['x1', 'x2', 'x3', 'x4', 'x5', 'x6', 'x7', 'x8', 'x9'];\r\n        if (symbols_sorted !== symbols_new) {\r\n            let dict = new Map();\r\n            for (let i = 0; i < symbols_sorted.length; i++) {\r\n                dict.set(symbols_sorted[i], symbols_new[i]);\r\n            }\r\n            node = node.transform(function (node) {\r\n                if (node.isSymbolNode && symbols.has(node.name)) {\r\n                    return new math.SymbolNode(dict.get(node.name));\r\n                }\r\n                else {\r\n                    return node;\r\n                }\r\n            });\r\n        }\r\n        console.log(node.toString());\r\n        /*node.traverse(function (node) {\r\n            var chck = node.isFunctionNode;\r\n            console.log(node.type, node.op, node.value,node.name,chck);\r\n        });*/\r\n        let compiled_node = node.compile();\r\n        return compiled_node;\r\n    }\r\n    catch (error) {\r\n        return -1;\r\n    }\r\n}\r\n/*function isStartPointCorrect(startPoint, lb, ub) {\r\n    for (let i = 0; i < DIM; i++) {\r\n        if (startPoint[i] > ub[i] || startPoint[i] < lb[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}*/\r\n\r\nfunction subtraction(a, b) {\r\n    let r = Object.create(a);\r\n    for (const property in a) {\r\n        r[property] = a[property] - b[property];\r\n    }\r\n    return r;\r\n}\r\nfunction addition(a, b) {\r\n    let r = Object.create(a);\r\n    for (const property in a) {\r\n        r[property] = a[property] + b[property];\r\n    }\r\n    return r;\r\n}\r\nfunction multiplication(a, b) {\r\n    let r = Object.create(b);\r\n    if (typeof a === \"number\") {\r\n        for (const property in b) {\r\n            r[property] = a * b[property];\r\n        }\r\n    }\r\n    else {\r\n        for (const property in a) {\r\n            r[property] = a[property] * b[property];\r\n        }\r\n    }\r\n    return r;\r\n}\r\nfunction division(a, b) {\r\n    let r = Object.create(a);\r\n    for (const property in a) {\r\n        r[property] = a[property] / b[property];\r\n    }\r\n    return r;\r\n}\r\n\r\nfunction hookeJeeves(x, f, eps, deltaVector, lambda, alpha, lb, ub) {\r\n    x = initializePoint(x);\r\n    let y = x, i = 1, yNext, xNext;\r\n    let functionIterations = 0;\r\n    let checkedPoints = [(Object.values(y).slice(0, DIM))];\r\n    let functionValues = [f.evaluate(y)];\r\n    yNext = Object.assign({}, y);\r\n    loop1: for (; ;) {\r\n        loop2: for (const key in y) {\r\n            //step 2a\r\n            yNext[key] += deltaVector[i - 1];\r\n            if (yNext[key] > ub[i - 1]) {\r\n                yNext[key] = ub[i - 1];\r\n            }\r\n            functionIterations += 2;\r\n            if (f.evaluate(yNext) < f.evaluate(y) - EPS) {\r\n                y = Object.assign({}, yNext);\r\n                checkedPoints.push((Object.values(y).slice(0, DIM)));\r\n                functionValues.push(f.evaluate(y));\r\n            }\r\n            else {//step 2b\r\n                yNext[key] = yNext[key] - 2 * deltaVector[i - 1];//cancel addition on the step2a and then subtraction\r\n                if (yNext[key] < lb[i - 1]) {\r\n                    yNext[key] = lb[i - 1];\r\n                }\r\n                functionIterations += 2;\r\n                if (f.evaluate(yNext) < f.evaluate(y) - EPS) {\r\n                    y = Object.assign({}, yNext);\r\n                    checkedPoints.push((Object.values(y).slice(0, DIM)));\r\n                    functionValues.push(f.evaluate(y));\r\n                }\r\n                else {\r\n                    yNext = Object.assign({}, y);\r\n                }\r\n            }\r\n            //step 3a\r\n            if (i < DIM) {\r\n                i++;\r\n                continue loop2;\r\n            }\r\n            //step 3b\r\n            if (i === DIM) {\r\n                //step 4\r\n                functionIterations += 2;\r\n                if (f.evaluate(yNext) < f.evaluate(x) - EPS) {\r\n                    xNext = Object.assign({}, yNext);\r\n                    y = addition(xNext, multiplication(lambda, (subtraction(xNext, x))));\r\n                    for (const key in y) {\r\n                        if (y[key] > ub[i - 1]) {\r\n                            y[key] = ub[i - 1];\r\n                        }\r\n                        else {\r\n                            if (y[key] < lb[i - 1]) {\r\n                                y[key] = lb[i - 1];\r\n                            }\r\n                        }\r\n                    }\r\n                    x = Object.assign({}, xNext);\r\n                    yNext = Object.assign({}, y);\r\n                    checkedPoints.push((Object.values(yNext).slice(0, DIM)));\r\n                    functionValues.push(f.evaluate(yNext));\r\n                    i = 1;\r\n                    break loop2;\r\n                }\r\n                else {//step 5a\r\n                    let r = deltaVector.filter(item => item < eps + EPS);\r\n                    if (r.length === deltaVector.length) {\r\n                        var xMin = Object.assign({}, x);\r\n                        functionIterations++;\r\n                        var fMin = f.evaluate(x);\r\n                        break loop1;\r\n                    }\r\n                    else {//step 5b\r\n                        for (let i = 0; i < deltaVector.length; i++) {\r\n                            if (deltaVector[i] > eps + EPS) {\r\n                                deltaVector[i] /= alpha;\r\n                            }\r\n                        }\r\n                        y = Object.assign({}, x);\r\n                        yNext = Object.assign({}, x);\r\n                        //x = Object.assign({},xNext);\r\n                        i = 1;\r\n                        break loop2;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    let methodOutput= new MethodOutput(checkedPoints, functionIterations, xMin, fMin, functionValues)\r\n    return methodOutput;\r\n}\r\n\r\n\r\nclass DoubleSidedMap {\r\n    constructor(keys, values) {\r\n        this.keys = keys;\r\n        this.values = values;\r\n    }\r\n    getByKey(key) {\r\n        const index = this.keys.findIndex(it => it === key);\r\n        return this.values[index];\r\n    }\r\n    getByValue(value) {\r\n        const index = this.values.findIndex(it => it === value);\r\n        return this.keys[index];\r\n    }\r\n}\r\nfunction getRandomInt(min, max) {\r\n    min = Math.ceil(min);\r\n    max = Math.floor(max);\r\n    return Math.floor(Math.random() * (max - min) + min);\r\n}\r\n\r\nfunction getMinimum(population) {\r\n    let minValue = Number.MAX_SAFE_INTEGER;\r\n    for (let i = 0; i < population.length; i++) {\r\n        let v = population[i].value;\r\n        if (v < minValue - EPS) {\r\n            var idxMin = i;\r\n            minValue = v;\r\n        }\r\n    }\r\n    return idxMin;\r\n}\r\nfunction getMaximum(population) {\r\n    let maxValue = Number.MIN_SAFE_INTEGER;\r\n    for (let i = 0; i < population.length; i++) {\r\n        let v = population[i].value;\r\n        if (v - EPS > maxValue) {\r\n            var idxMax = i;\r\n            maxValue = v;\r\n        }\r\n    }\r\n    return idxMax;\r\n}\r\nfunction arrayContainsIn(mainArr, arr) {\r\n    for (const it of mainArr) {\r\n        let count = 0;\r\n        for (let i = 0; i < it.length; i++) {\r\n            if (Math.abs(it[i] - arr[i]) < EPS) {\r\n                count++;\r\n            }\r\n        }\r\n        if (count === arr.length) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction geneticBinary(tMax, m, f, lb, ub, li) {\r\n    function buildGrey(li) {\r\n        let grey = new Array(2 ** li);\r\n        grey[0] = \"0\";\r\n        grey[1] = \"1\";\r\n        let p = 2;\r\n        for (let i = 2; i <= li; i++) {\r\n            let t = p - 1;\r\n            p *= 2;\r\n            for (let k = Math.floor(p / 2); k < p; k++) {\r\n                grey[k] = grey[t];\r\n                grey[t] = \"0\" + grey[t];\r\n                grey[k] = \"1\" + grey[k];\r\n                t--;\r\n            }\r\n        }\r\n        return grey;\r\n    }\r\n    let numbers = new Array(2 ** li);\r\n    for (let i = 0; i < 2 ** li; i++) {\r\n        numbers[i] = i;\r\n    }\r\n    let greys = buildGrey(li);\r\n    let mapGrey = new DoubleSidedMap(numbers, greys);\r\n    let k = 2 ** li - 1;\r\n    class Creature {\r\n        constructor(genotype) {\r\n            this.genotype = genotype;\r\n            this.value = getValue(decode(genotype));\r\n        }\r\n        static crossover(parents) { //одноточечное скрещивание\r\n            let parentA = parents[0].genotype, parentB = parents[1].genotype;\r\n            //parentA=[\"1110\",\"1000\",\"1010\"], B=[\"0001\",\"0100\",\"0101\"] 1..DIM\r\n            //\"111010001010\"->\"111.010001010\"->\"111101000101\"->\"1111,0100,0101\"\r\n            //\"000101000101\"->\"000.101000101\"->\"000010001010\"->\"0000,1000,1010\"\r\n            let pA = \"\", pB = \"\";\r\n            for (let i = 0; i < DIM; i++) {\r\n                pA += parentA[i];\r\n                pB += parentB[i];\r\n            }\r\n            let len = pA.length;\r\n            let idx = getRandomInt(1, len);\r\n            let pA1 = pA.slice(0, idx), pA2 = pA.slice(idx, len);\r\n            let pB1 = pB.slice(0, idx), pB2 = pB.slice(idx, len);\r\n            let gsch1 = pA1 + pB2;\r\n            let gsch2 = pB1 + pA2;\r\n            let re = new RegExp(`\\\\d{${li}}`, `g`);\r\n            gsch1 = gsch1.match(re);\r\n            gsch2 = gsch2.match(re);\r\n            let sch1 = new Creature(gsch1), sch2 = new Creature(gsch2);\r\n            return [sch1, sch2];\r\n        }\r\n        mutate() { //инверсия\r\n            let g = this.genotype;\r\n            let gString = \"\";\r\n            for (let i = 0; i < DIM; i++) {\r\n                gString += g[i];\r\n            }\r\n            let len = gString.length;\r\n            let idx = getRandomInt(1, len);\r\n            let gS1 = gString.slice(0, idx), gS2 = gString.slice(idx, len);\r\n            let gString_ = gS2 + gS1;\r\n            let re = new RegExp(`\\\\d{${li}}`, `g`);\r\n            this.genotype = gString_.match(re);\r\n            this.value = getValue(decode(this.genotype));\r\n        }\r\n        containsIn(arr) {\r\n            for (const i of arr) {\r\n                if (i.genotype === this.genotype) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n    function code(fenotype) {\r\n        let genotype = new Array(DIM);\r\n        //fenotype=[p1,p2,..,pn] -> genotype=[\"1010\",\"1111\",...,\"1100\"]\r\n        //priznak=pi\r\n        //chromosom=\"abcd\"\r\n        for (let i = 0; i < DIM; i++) {\r\n            let chromosom, beta;\r\n            let priznak = fenotype[i];\r\n            if (Math.abs(priznak - lb[i]) < EPS) {\r\n                beta = 0;\r\n            }\r\n            else {\r\n                let h = (ub[i] - lb[i]) / (k - 1);\r\n                beta = Math.floor((priznak - lb[i]) / h) + 1;//номер признака\r\n                chromosom = mapGrey.getByKey(beta);\r\n            }\r\n            genotype[i] = chromosom;\r\n        }\r\n        return genotype;\r\n    }\r\n    function decode(genotype) {\r\n        let genotypeDecoded = new Array(DIM);\r\n        for (let i = 0; i < DIM; i++) {\r\n            let priznak;\r\n            let gamma = mapGrey.getByValue(genotype[i]);\r\n            if (gamma === 0) {\r\n                priznak = lb[i];\r\n            }\r\n            else {\r\n                if (gamma === k) {\r\n                    priznak = ub[i];\r\n                }\r\n                else {\r\n                    let h = (ub[i] - lb[i]) / (k - 1);\r\n                    priznak = ((lb[i] + (gamma - 1) * h) + (lb[i] + gamma * h)) / 2;\r\n                }\r\n            }\r\n            genotypeDecoded[i] = priznak;\r\n        }\r\n        return genotypeDecoded;\r\n    }\r\n    function getValue(g) {\r\n        let x = initializePoint(g);\r\n        let fx = f.evaluate(x);\r\n        return fx;\r\n    }\r\n    let t = 0, M = 1;\r\n    //шаг 1 начальная популяция\r\n    let P = new Array(m);\r\n    let population = new Array(m);\r\n    //let sumOfValues=0;\r\n    let functionIterations = m, checkedPoints = [], functionValues = [];\r\n    for (let i = 0; i < m; i++) {\r\n        P[i] = new Array(DIM);\r\n        for (let j = 0; j < DIM; j++) {\r\n            P[i][j] = (ub[j] - lb[j]) * Math.random() + lb[j];\r\n        }\r\n        let fenotype = P[i];\r\n        let genotype = code(fenotype);\r\n        let c = new Creature(genotype);\r\n        //sumOfValues+=c.value;\r\n        population[i] = c;\r\n    }\r\n    let idxMin = getMinimum(population);\r\n    let xk = decode(population[idxMin].genotype);\r\n    let xMin = initializePoint(xk);\r\n    let fMin = f.evaluate(xMin);\r\n    if (!arrayContainsIn(checkedPoints, xk)) {\r\n        checkedPoints.push(xk);\r\n        functionValues.push(fMin);\r\n    }\r\n    /*let probabilities=new Array(m+1);\r\n    probabilities[0]=0;\r\n    for (let i = 1; i < m+1; i++) {\r\n        probabilities[i]=probabilities[i-1]+population[i-1].value/sumOfValues;\r\n    }*/\r\n    //шаг 2. селекция\r\n    step2: for (; ;) {\r\n        let probabilityInterval = new Array(m + 1);\r\n        let parents = [];\r\n        probabilityInterval[0] = 0;\r\n        for (let i = 1; i < m + 1; i++) {\r\n            probabilityInterval[i] = probabilityInterval[i - 1] + 1 / m; //панмиксия\r\n        }\r\n        masterLoop: for (; ;) {\r\n            let coin = Math.random();\r\n            slaveLoop: for (let i = 1; i < m + 1; i++) {\r\n                if (probabilityInterval[i - 1] < coin && coin < probabilityInterval[i]) {\r\n                    let childCandidate = population[i - 1];\r\n                    if (!childCandidate.containsIn(parents)) {\r\n                        parents.push(childCandidate);\r\n                        if (parents.length === 2) {\r\n                            break masterLoop;\r\n                        }\r\n                        else {\r\n                            continue masterLoop;\r\n                        }\r\n                    }\r\n                    else {\r\n                        continue masterLoop;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        //шаг 3 скрещивание\r\n        let [sch1, sch2] = Creature.crossover(parents);\r\n        //шаг 4 мутация\r\n        sch1.mutate();\r\n        sch2.mutate();\r\n        functionIterations += 2;\r\n        let idxMax = getMaximum(population);\r\n        let coin = Math.random();\r\n        if (coin - EPS > 0.5) {\r\n            population[idxMax] = sch1;\r\n        }\r\n        else {\r\n            population[idxMax] = sch2;\r\n        }\r\n        let idxMin = getMinimum(population);\r\n        let xk = decode(population[idxMin].genotype);\r\n        xMin = initializePoint(xk);\r\n        fMin = f.evaluate(xMin);\r\n        if (!arrayContainsIn(checkedPoints, xk)) {\r\n            checkedPoints.push(xk);\r\n            functionValues.push(fMin);\r\n        }\r\n        if (M < m) {\r\n            M++;\r\n            continue step2;\r\n        }\r\n        if (M === m) {\r\n            t++;\r\n        }\r\n        if (t === tMax) {\r\n            let idxMin = getMinimum(population);\r\n            let xk = decode(population[idxMin].genotype);\r\n            xMin = initializePoint(xk);\r\n            fMin = f.evaluate(xMin);\r\n            if (!arrayContainsIn(checkedPoints, xk)) {\r\n                checkedPoints.push(xk);\r\n                functionValues.push(fMin);\r\n            }\r\n            break step2;\r\n        }\r\n        else {\r\n            M = 1;\r\n            continue step2;\r\n        }\r\n    }\r\n    let methodOutput= new MethodOutput(checkedPoints, functionIterations, xMin, fMin, functionValues)\r\n    return methodOutput;\r\n}\r\nfunction particleSwarm(f, lb, ub, K, np, niVector, omega, alpha, beta) {\r\n    let NImin = niVector[0], NImax = niVector[1];\r\n    class Creature {\r\n        constructor(position) {\r\n            this.position = position;\r\n            this.bestPosition = position;\r\n            this.value = f.evaluate(initializePoint(position));\r\n            this.speed = new Array(DIM);\r\n            for (let i = 0; i < DIM; i++) {\r\n                this.speed[i] = 0;\r\n            }\r\n        }\r\n        changePosition(bestPositionOfNeighbors) {\r\n            let first, second, third;\r\n            first = math.multiply(omega, this.speed);\r\n            masterLoop: for (let i = 0; i < 20; i++) {\r\n                let r1 = Math.random(), r2 = Math.random();\r\n                second = math.multiply((alpha * r1), math.subtract(this.bestPosition, this.position));\r\n                third = math.multiply((omega * beta * r2), math.subtract(bestPositionOfNeighbors, this.position));\r\n                this.speed = math.add(first, second, third);\r\n                this.position = math.add(this.position, this.speed);\r\n                slaveLoop: for (let i = 0; i < DIM; i++) {\r\n                    if (this.position[i] - EPS > ub[i] || this.position[i] < lb[i] - EPS) {\r\n                        continue masterLoop;\r\n                    }\r\n                    else {\r\n                        break masterLoop;\r\n                    }\r\n                }\r\n            }\r\n            for (let i = 0; i < DIM; i++) {\r\n                if (this.position[i] - EPS > ub[i]) {\r\n                    this.position[i] = ub[i];\r\n                }\r\n                else {\r\n                    if (this.position[i] < lb[i] - EPS) {\r\n                        this.position[i] = lb[i];\r\n                    }\r\n                }\r\n            }\r\n            let posValue = f.evaluate(initializePoint(this.position));\r\n            this.value = posValue;\r\n            if (posValue < f.evaluate(initializePoint(this.bestPosition)) - EPS) {\r\n                this.bestPosition = this.position;\r\n            }\r\n        }\r\n    }\r\n    //step 2\r\n    let P = new Array(np);\r\n    let population = new Array(np);\r\n    let functionIterations = 0, checkedPoints = [], functionValues = [];\r\n    for (let i = 0; i < np; i++) {\r\n        P[i] = new Array(DIM);\r\n        for (let j = 0; j < DIM; j++) {\r\n            P[i][j] = (ub[j] - lb[j]) * Math.random() + lb[j];\r\n        }\r\n        let creaturePosition = P[i];\r\n        let c = new Creature(creaturePosition);\r\n        population[i] = c;\r\n    }\r\n    let idxMin = getMinimum(population);\r\n    let xArr = population[idxMin].position;\r\n    let xMin = initializePoint(xArr);\r\n    let fMin = f.evaluate(xMin);\r\n    if (!arrayContainsIn(checkedPoints, xArr)) {\r\n        checkedPoints.push(xArr);\r\n        functionValues.push(fMin);\r\n    }\r\n    //step 3\r\n    for (let k = 0; k < K; k++) {\r\n        for (let j = 0; j < np; j++) {\r\n            let ni = getRandomInt(NImin, NImax + 1);//+1 because NImax should present.\r\n            let neighbors = new Set();\r\n            while (neighbors.size < ni) {\r\n                let idx = getRandomInt(0, np);\r\n                neighbors.add(population[idx]);\r\n            }\r\n            let minValueOfNeighbors = Number.MAX_SAFE_INTEGER;\r\n            let bestPositionOfNeighbors;\r\n            for (const c of neighbors) {\r\n                if (c.value < minValueOfNeighbors - EPS) {\r\n                    minValueOfNeighbors = c.value;\r\n                    bestPositionOfNeighbors = c.position;\r\n                }\r\n            }\r\n            //step 4\r\n            let c = population[j];\r\n            functionIterations += 2;\r\n            c.changePosition(bestPositionOfNeighbors);\r\n            let idxMin = getMinimum(population);\r\n            let xArr = population[idxMin].position;\r\n            let xMin = initializePoint(xArr);\r\n            let fMin = f.evaluate(xMin);\r\n            if (!arrayContainsIn(checkedPoints, xArr)) {\r\n                checkedPoints.push(xArr);\r\n                functionValues.push(fMin);\r\n            }\r\n        }\r\n    }\r\n    idxMin = getMinimum(population);\r\n    xArr = population[idxMin].position;\r\n    xMin = initializePoint(xArr);\r\n    fMin = f.evaluate(xMin);\r\n    if (!arrayContainsIn(checkedPoints, xArr)) {\r\n        checkedPoints.push(xArr);\r\n        functionValues.push(fMin);\r\n    }\r\n    let methodOutput= new MethodOutput(checkedPoints, functionIterations, xMin, fMin, functionValues)\r\n    return methodOutput;\r\n}\r\nfunction tabuSearch(f, lb, ub, M, N, L,allowModification) {\r\n    let functionIterations = 0;\r\n    let maxEdge = Number.MIN_SAFE_INTEGER;\r\n    for (let i = 0; i < DIM; i++) {\r\n        let edge = ub[i] - lb[i];\r\n        if (edge - EPS > maxEdge) {\r\n            maxEdge = edge;\r\n        }\r\n    }\r\n    const delta = maxEdge;\r\n    const Rtr = delta / 100, Rstr = delta / 50;\r\n    const p = delta / 5;\r\n    const gamma = 0.25;\r\n    const L_ = 2 * DIM;\r\n    const Nmax = 1, Nmin = 1 / L;\r\n    const Mmax = 1, Mmin = 1 / L;\r\n    class TabuList {\r\n        constructor(arr) {\r\n            this.points = arr;\r\n            this.length = arr.length;\r\n        }\r\n        push(item) {\r\n            for (let i = 0; i < this.points.length; i++) {\r\n                this.points[i].Ir++;\r\n            }\r\n            this.points.push(item);\r\n            this.length++;\r\n            this.points.sort((a, b) => { return a.value - b.value });\r\n            for (let i = 1; i <= this.points.length; i++) {\r\n                this.points[i - 1].If = i;\r\n            }\r\n\r\n            for (let i = 0; i < this.points.length; i++) {\r\n                let item = this.points[i];\r\n                let Mr = Nmin + (Nmax - Nmin) * (L - item.Ir) / (L - 1);\r\n                if (item.If <= L_) {\r\n                    var Mf = Mmin + (Mmax - Mmin) * (L_ - item.If) / (L_ - 1);\r\n                }\r\n                else {\r\n                    var Mf = Mmin;\r\n                }\r\n                this.points[i].mValue = Math.max(Mr, Mf);\r\n            }\r\n        }\r\n        index(i) {\r\n            return this.points[i];\r\n        }\r\n        remove(index) {\r\n            let Ir_ = this.points[index].Ir; //8 out of 10\r\n            for (let i = 0; i < this.points.length; i++) {\r\n                if (this.points[i].Ir > Ir_) {\r\n                    this.points[i].Ir--;\r\n                }\r\n            }\r\n            this.points.splice(index, 1); //removing\r\n            this.length--;\r\n        }\r\n    }\r\n    class TabuPoint {\r\n        constructor(coordinate) {\r\n            this.coordinate = coordinate;\r\n            this.value = f.evaluate(initializePoint(coordinate));\r\n            this.Ir = 1;\r\n            this.If = 1;\r\n            this.mValue = 0;\r\n        }\r\n    }\r\n    class Region {\r\n        constructor(coordinate) {\r\n            this.coordinate = coordinate;\r\n            this.p = p;\r\n            this.phi = 1;\r\n        }\r\n    }\r\n\r\n    function getCentersOfTouchedSemiTabuRegions(tabuList, x, Rstr) {\r\n        let centers = [];\r\n        for (let i = 0; i < tabuList.length; i++) {\r\n            let t = tabuList.index(i).coordinate;\r\n            let lp = 0;\r\n            for (let j = 0; j < DIM; j++) {\r\n                lp += (x[j] - t[j]) ** 2;\r\n            }\r\n            if (lp < Rstr ** 2 - EPS) {\r\n                centers.push(t);\r\n            }\r\n        }\r\n        return centers;\r\n    }\r\n    function getMaxDistance(x, t) {\r\n        let Dmax = Number.MIN_SAFE_INTEGER;\r\n        for (let i = 0; i < t.length; i++) {\r\n            let r = math.norm(math.subtract(x, t[i]));\r\n            if (r > Dmax) {\r\n                Dmax = r;\r\n            }\r\n        }\r\n        return Dmax;\r\n    }\r\n    function getDirection(x, t_) {\r\n        let d = new Array(DIM);\r\n        for (let i = 0; i < DIM; i++) {\r\n            d[i] = Math.sign(x[i] - t_[i]);\r\n        }\r\n        return d;\r\n    }\r\n    function getStep(delta, Dmax, Rtr) {\r\n        let delta_ = new Array(DIM);\r\n        for (let i = 0; i < DIM; i++) {\r\n            let r = Math.random();\r\n            if (r === 0) {\r\n                r = EPS;\r\n            }\r\n            delta_[i] = delta * (1 + r) / 10;\r\n            if (delta_[i] < Dmax + Rtr) {\r\n                delta_[i] += Rtr;\r\n                if (delta_[i] < Dmax + Rtr) {\r\n                    delta_[i] += Dmax;\r\n                }\r\n            }\r\n        }\r\n        return delta_;\r\n    }\r\n    function adaptiveSearch(x, y, delta) {\r\n        let sumOfDeltaF = 0;\r\n        let fx = f.evaluate(initializePoint(x));\r\n        let w = new Array(DIM), u = new Array(DIM), v = new Array(DIM);\r\n        for (let i = 0; i < DIM; i++) {\r\n            v[i] = 0;\r\n        }\r\n        for (let i = 0; i < DIM; i++) {\r\n            let df = f.evaluate(initializePoint(y[i])) - fx;\r\n            functionIterations++;\r\n            w[i] = df;\r\n            sumOfDeltaF += df;\r\n        }\r\n        for (let i = 0; i < DIM; i++) {\r\n            w[i] /= sumOfDeltaF;\r\n            let a = math.subtract(y[i], x);\r\n            let zer = math.zeros(DIM);\r\n            let uNum = math.subtract(zer, a);\r\n            let uDen = math.norm(a);\r\n            u[i] = math.divide(uNum, uDen);\r\n            v = math.add(v, math.multiply(w[i], u[i]));\r\n        }\r\n        for (let i = 0; i < 2; i++) {\r\n            let sigma = Math.random() + i;\r\n            if (sigma === i) { sigma = EPS; }\r\n            let alpha = sigma * delta / 10;\r\n            let rp = math.multiply(alpha, math.divide(v, math.norm(v)));\r\n            let newPoint = math.add(x, rp);\r\n            for (let i = 0; i < DIM; i++) {\r\n                if (newPoint._data[i] > ub[i]) {\r\n                    newPoint._data[i] = ub[i];\r\n                }\r\n                else {\r\n                    if (newPoint._data[i] < lb[i]) {\r\n                        newPoint._data[i] = lb[i];\r\n                    }\r\n                }\r\n            }\r\n            y.push(newPoint._data);\r\n        }\r\n        let fMin = Number.MAX_SAFE_INTEGER;\r\n        for (let i = 0; i < y.length; i++) {\r\n            functionIterations++;\r\n            let fy = f.evaluate(initializePoint(y[i]));\r\n            if (fy < fMin) {\r\n                fMin = fy;\r\n                var xNext = y[i];\r\n            }\r\n        }\r\n        return xNext;\r\n    }\r\n    function updateTabuList(xNext, tabuList, L) {\r\n        let tabuPoint = new TabuPoint(xNext);\r\n        functionIterations++;\r\n        if (tabuList.length < L) {\r\n            tabuList.push(tabuPoint);\r\n        }\r\n        else {\r\n            let minValue = Number.MAX_SAFE_INTEGER;\r\n            let idxMin;\r\n            for (let i = 0; i < tabuList.length; i++) {\r\n                if (tabuList.index(i).mValue < minValue) {\r\n                    minValue = tabuList.index(i).mValue;\r\n                    idxMin = i;\r\n                }\r\n            }\r\n            tabuList.remove(idxMin);\r\n            tabuList.push(tabuPoint);\r\n        }\r\n    }\r\n    function updateVisitedRegionList(xNext, visitedRegionList) {\r\n        let isRegionTouched = false;\r\n        for (let i = 0; i < visitedRegionList.length; i++) {\r\n            let t = visitedRegionList[i].coordinate;\r\n            let lp = 0;\r\n            for (let j = 0; j < DIM; j++) {\r\n                lp += (xNext[j] - t[j]) ** 2;\r\n            }\r\n            if (lp < visitedRegionList[i].p ** 2 - EPS) {\r\n                visitedRegionList[i].phi++;\r\n                isRegionTouched = true;\r\n            }\r\n        }\r\n        if (!isRegionTouched) {\r\n            let newRegion = new Region(xNext);\r\n            visitedRegionList.push(newRegion);\r\n        }\r\n    }\r\n    let tabuList = new TabuList([]);\r\n    let visitedRegionList = [], checkedPoints = [], functionValues = [];\r\n    let x = new Array(DIM);\r\n    for (let i = 0; i < DIM; i++) {\r\n        x[i] = Math.random() * (ub[i] - lb[i]) + lb[i];\r\n    }\r\n    for (let j = 0; j < N; j++) {\r\n        //step 2.1 исследовательский поиск\r\n        for (let k = 0; k < M; k++) {\r\n            //step 2.1.1\r\n            checkedPoints.push(x);\r\n            functionValues.push(f.evaluate(initializePoint(x)));\r\n            let t = getCentersOfTouchedSemiTabuRegions(tabuList, x, Rstr);\r\n            let v = t.length;\r\n            if (v !== 0) {\r\n                let sum = new Array(DIM), t_ = new Array(DIM);\r\n                for (let i = 0; i < DIM; i++) {\r\n                    sum[i] = 0;\r\n                    t_[i] = 0;\r\n                }\r\n                for (let i = 0; i < t.length; i++) {\r\n                    sum = math.add(sum, t[i]);\r\n                }\r\n                t_ = math.divide(sum, v);\r\n                var Dmax = getMaxDistance(x, t);\r\n                var directionVector = getDirection(x, t_);\r\n            }\r\n            else {\r\n                var directionVector = new Array(DIM);\r\n                for (let i = 0; i < DIM; i++) {\r\n                    let coin = Math.random();\r\n                    if (coin > 0.5) {\r\n                        directionVector[i] = 1;\r\n                    }\r\n                    else {\r\n                        directionVector[i] = -1;\r\n                    }\r\n                }\r\n                var Dmax = 0;\r\n            }\r\n            //step 2.1.2\r\n            let delta_ = getStep(delta, Dmax, Rtr);\r\n            //step 2.1.3\r\n            var y = new Array(DIM);\r\n            let fxNext = Number.MAX_SAFE_INTEGER;\r\n            var xNext = Object.values(x).slice(0, DIM);\r\n            for (let i = 0; i < DIM; i++) {\r\n                y[i] = new Array(DIM);\r\n                for (let j = 0; j < DIM; j++) {\r\n                    y[i][j] = x[j];\r\n                }\r\n                y[i][i] += delta_[i] * directionVector[i];\r\n                if (y[i][i] > ub[i]) {\r\n                    y[i][i] = ub[i];\r\n                }\r\n                else {\r\n                    if (y[i][i] < lb[i]) {\r\n                        y[i][i] = lb[i];\r\n                    }\r\n                }\r\n                functionIterations++;\r\n                let fy = f.evaluate(initializePoint(y[i]));\r\n                if (fy < fxNext) {\r\n                    fxNext = fy;\r\n                    xNext = y[i];\r\n                }\r\n            }\r\n            //step 2.1.4\r\n            functionIterations++;\r\n            if (!(fxNext < f.evaluate(initializePoint(x)))) {\r\n                if (allowModification===true){\r\n                    //t0,iters,c,beta\r\n                    let returned=simulatedAnnealing(5,50,x,f,0.85,0.96,lb,ub);\r\n                    functionIterations+=returned.functionIterations;\r\n                    xNext=Object.values(returned.xMin).slice(0, DIM);\r\n                }\r\n                else{\r\n                    xNext = adaptiveSearch(x, y, delta);\r\n                }\r\n            }\r\n            //step 2.1.5\r\n            updateTabuList(x, tabuList, L);\r\n            updateVisitedRegionList(x, visitedRegionList);\r\n            x = Object.assign([],xNext);\r\n        }\r\n        //step 2.2 перераспределительный поиск\r\n        masterLoop: for (; ;) {\r\n            var z = new Array(DIM);\r\n            for (let i = 0; i < DIM; i++) {\r\n                z[i] = Math.random() * (ub[i] - lb[i]) + lb[i];\r\n            }\r\n            for (let i = 0; i < visitedRegionList.length; i++) {\r\n                let r = visitedRegionList[i];\r\n                let Phi = gamma * (1 - Math.exp(-gamma * (r.phi - 1)));\r\n                let s = (1 + Phi) * math.norm(math.subtract(r.coordinate, z));\r\n                if (s / p < 1) {\r\n                    continue masterLoop;\r\n                }\r\n            }\r\n            break masterLoop;\r\n        }\r\n        x = Object.assign([],z);\r\n    }\r\n    //step 3 интенсивно-уточняющий поиск\r\n    let eps = 0.2, deltaVector = [1, 1], lambda = 1, alpha = 1.2;\r\n    let fMin = Number.MAX_SAFE_INTEGER;\r\n    for (let i = 0; i < L_; i++) {\r\n        let startPoint = tabuList.index(i).coordinate;\r\n        let returnedFromMethod = hookeJeeves(startPoint, f, eps, deltaVector, lambda, alpha, lb, ub);\r\n        functionIterations += returnedFromMethod.functionIterations;\r\n        let returnedfMin = returnedFromMethod.fMin;\r\n        if (returnedfMin < fMin) {\r\n            fMin = returnedfMin;\r\n            var xMin = returnedFromMethod.xMin;\r\n            checkedPoints.push(Object.values(xMin).slice(0, DIM));\r\n            functionValues.push(fMin);\r\n        }\r\n    }\r\n    let methodOutput= new MethodOutput(checkedPoints, functionIterations, xMin, fMin, functionValues)\r\n    return methodOutput;\r\n}\r\nfunction startOptimization(selectedMethodString, params) {\r\n    let objectiveFunctionString = params.objectiveFunction;\r\n    /*if (params.Aeq !== undefined || params.Beq !== undefined){\r\n        var Aeq=params.Aeq;\r\n        var Beq=params.Beq;\r\n    }*/\r\n    let re = /[\\w.-]+/g;\r\n    let lowerBound = params.lowerBound.match(re);\r\n    let upperBound = params.upperBound.match(re);\r\n    \r\n    DIM = lowerBound.length;\r\n    for (let i = 0; i < DIM; i++) {\r\n        lowerBound[i] = parseFloat(lowerBound[i]);\r\n        upperBound[i] = parseFloat(upperBound[i]);\r\n        if (isNaN(lowerBound[i])) {\r\n            lowerBound[i] = Number.MIN_SAFE_INTEGER;\r\n        }\r\n        if (isNaN(upperBound[i])) {\r\n            upperBound[i] = Number.MAX_SAFE_INTEGER;\r\n        }\r\n    }\r\n\r\n    let objectiveFunction = parseFunction(objectiveFunctionString, DIM);\r\n    if (objectiveFunction === -1) {\r\n        return -1;\r\n    }\r\n    \r\n    switch (selectedMethodString) {\r\n        case \"HJ\": {\r\n            if (CheckStringVector(params.startPoint)!==0){\r\n                return -2;\r\n            }\r\n            let allowModification=params.mod;\r\n            if (allowModification===undefined){\r\n                allowModification=false;\r\n            }\r\n            \r\n            let eps = parseFloat(params.eps);\r\n            let alpha = parseFloat(params.alpha);\r\n            let lambda = parseFloat(params.lambda);\r\n            let deltaVector = params.deltaVector.match(/[\\d.]+/g);\r\n            for (let i = 0; i < deltaVector.length; i++) {\r\n                deltaVector[i] = parseFloat(deltaVector[i]);\r\n            }\r\n\r\n            \r\n            if (allowModification===true){\r\n                let pointsList=[],point;\r\n                let n=100;\r\n                for (let i = 0; i < n; i++) {\r\n                    point=[getRandomInt(lowerBound[0],upperBound[0]),getRandomInt(lowerBound[1],upperBound[1])];\r\n                    pointsList.push(point);\r\n                }\r\n                //[checkedPoints, functionIterations, xMin, fMin, functionValues];\r\n                let minF=Number.MAX_SAFE_INTEGER;\r\n                let bestResult, totalFunctionIterations=0;\r\n                var start=Date.now();\r\n                for (let i = 0; i < n; i++) {\r\n                    let startPoint=pointsList[i];\r\n                    let returned = hookeJeeves(startPoint, objectiveFunction, eps, deltaVector, lambda, alpha, lowerBound, upperBound);\r\n                    let curF=returned.fMin;\r\n                    totalFunctionIterations+=returned.functionIterations;\r\n                    if (curF < minF){\r\n                        minF=curF;\r\n                        bestResult = Object.assign([],returned);\r\n                    }\r\n                }\r\n                var methodTime=Date.now()-start;\r\n                bestResult.functionIterations=totalFunctionIterations;\r\n                var returnedFromMethod = Object.assign([],bestResult);\r\n            }\r\n            else{\r\n                let startPoint = parseStartPoint(params.startPoint,lowerBound,upperBound);\r\n                if (startPoint === -2) {\r\n                    return -2;\r\n                }\r\n                var start=Date.now();\r\n                var returnedFromMethod = hookeJeeves(startPoint, objectiveFunction, eps, deltaVector, lambda, alpha, lowerBound, upperBound);\r\n                var methodTime=Date.now()-start;\r\n            }\r\n            break;\r\n        }\r\n        case \"SA\": {\r\n            if (CheckStringVector(params.startPoint)!==0){\r\n                return -2;\r\n            }\r\n            let startPoint = parseStartPoint(params.startPoint,lowerBound,upperBound);\r\n            if (startPoint === -2) {\r\n                return -2;\r\n            }\r\n            let maxIter = parseInt(params.maxIterations);\r\n            let startT = parseFloat(params.initialTemperature);\r\n            let c = parseFloat(params.c);\r\n            let beta = parseFloat(params.beta);\r\n            \r\n            \r\n            var start=Date.now();\r\n            var returnedFromMethod = simulatedAnnealing(startT, maxIter, startPoint, objectiveFunction, c, beta, lowerBound, upperBound);\r\n            var methodTime=Date.now()-start;\r\n            break;\r\n        }\r\n        case \"Genetic\": {\r\n            let tMax = parseInt(params.maxIterations), m = parseInt(params.m), li = parseInt(params.li);\r\n            var start=Date.now();\r\n            var returnedFromMethod = geneticBinary(tMax, m, objectiveFunction, lowerBound, upperBound, li);\r\n            var methodTime=Date.now()-start;\r\n            break;\r\n        }\r\n        case \"Swarm\": {\r\n            let maxIter = parseInt(params.maxIterations);\r\n            let np = parseInt(params.np);\r\n            let ni = params.ni.match(/[\\d.]+/g);\r\n            for (let i = 0; i < ni.length; i++) {\r\n                ni[i] = parseInt(ni[i]);\r\n            }\r\n            let omega = parseFloat(params.omega);\r\n            let alpha = parseFloat(params.alpha);\r\n            let beta = parseFloat(params.beta);\r\n            var start=Date.now();\r\n            var returnedFromMethod = particleSwarm(objectiveFunction, lowerBound, upperBound,\r\n                maxIter, np, ni, omega, alpha, beta);\r\n            var methodTime=Date.now()-start;\r\n            break;\r\n        }\r\n        case \"Tabu\": {\r\n            let M = parseInt(params.M), N = parseInt(params.N), L = parseInt(params.L);\r\n            let allowModification=params.mod;\r\n            if (allowModification === undefined){\r\n                allowModification=false;\r\n            }\r\n            var start=Date.now();\r\n            var returnedFromMethod = tabuSearch(objectiveFunction, lowerBound, upperBound,\r\n                M, N, L,allowModification);\r\n            var methodTime=Date.now()-start;\r\n            break;\r\n        }\r\n        // no default\r\n    }\r\n    let checkedPoints, functionIterations, xMin, fMin, functionValues;\r\n    checkedPoints = returnedFromMethod.checkedPoints;\r\n    functionIterations = returnedFromMethod.functionIterations;\r\n    xMin = returnedFromMethod.xMin;\r\n    fMin = returnedFromMethod.fMin;\r\n    functionValues = returnedFromMethod.functionValues;\r\n    let data={\r\n        checkedPoints:checkedPoints,\r\n        functionIterations:functionIterations,\r\n        xMin:xMin,\r\n        fMin: fMin,\r\n        DIM: DIM,\r\n        functionValues:functionValues,\r\n        methodTime : methodTime\r\n    }\r\n    if (DIM <= 2) {\r\n        let [X, Y, checkedPointsT, labelsList] = getValuesForPlot(objectiveFunction, lowerBound, upperBound, checkedPoints);\r\n        data.X=X;\r\n        data.Y=Y;\r\n        data.checkedPointsT=checkedPointsT;\r\n        data.labelsList=labelsList;\r\n    }\r\n    return data;\r\n}\r\nexport { startOptimization, CheckStringVector };","function getPlot(X, Z, labelsList, checkedPoints, xMin,fMin,DIM) {\r\n    let scatterData = {\r\n        x: checkedPoints[0],\r\n        y: checkedPoints[1],\r\n        type: \"scatter\",\r\n        line: { color: \"red\" },\r\n        text: labelsList,\r\n        textposition: \"top center\",\r\n        mode: \"lines+markers+text\",\r\n        textfont: { color: \"white\" },\r\n        hoverinfo: \"x+y+z\",\r\n        name: \"Линия поиска\"\r\n    };\r\n    \r\n    switch (DIM) {\r\n        case 1:\r\n            var contourData = {\r\n                x: X[0],\r\n                y: Z,\r\n                type: \"scatter\",\r\n                line: { color: \"black\" },\r\n                hoverinfo: \"x+y\",\r\n                name: \"Целевая функция\"\r\n            };\r\n            var scatterMinData = {\r\n                x: [xMin.x1],\r\n                y: [fMin],\r\n                type: \"scatter\",\r\n                line: { color: \"Green\" },\r\n                marker: { symbol:\"diamond\",size:10 },\r\n                hoverinfo: \"x+y+z\",\r\n                name: \"x*\"\r\n            };\r\n            break;\r\n        case 2:\r\n            var contourData = {\r\n                x: X[0],\r\n                y: X[1],\r\n                z: Z,\r\n                type: \"contour\",\r\n                contours: { start: -900, end: 600, size: 20 },\r\n                name: \"Линии уровня\"\r\n            };\r\n            var scatterMinData = {\r\n                x: [xMin.x1],\r\n                y: [xMin.x2],\r\n                type: \"scatter\",\r\n                line: { color: \"Green\" },\r\n                marker: { symbol:\"diamond\",size:10 },\r\n                hoverinfo: \"x+y+z\",\r\n                name: \"x*\"\r\n            };\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n    let data = [scatterData,scatterMinData, contourData];\r\n\r\n    let layout = {\r\n        margin: { t: 10 },\r\n        hovermode: \"closest\",\r\n        showlegend: false\r\n    };\r\n    return [data,layout];\r\n}\r\n\r\nexport default getPlot;","import { useState } from \"react\";\nimport Options from \"./components/Options\"\nimport InputRow from \"./components/InputRow\";\nimport { startOptimization, CheckStringVector } from \"./modules/main\";\nimport getPlot from \"./modules/plot\"\nimport createPlotlyComponent from 'react-plotly.js/factory'\nimport Plotly from 'plotly.js-cartesian-dist'\nimport { BrowserView } from 'react-device-detect';\nimport \"./App.css\"\nvar parametersList = [];\n\nconst Plot = createPlotlyComponent(Plotly);\nconst rowsData = [\n  { id: \"objectiveFunction\", name: \"Целевая функция\", required: \"required\", pattern: \"[a-zA-Z0-9 +/.*^()-]+\" },\n  { id: \"lowerBound\", name: \"Нижняя граница\", required: \"required\", pattern: \"[pie\\\\d .,;\\\\[\\\\]-]+\" },\n  { id: \"upperBound\", name: \"Верхняя граница\", required: \"required\", pattern: \"[pie\\\\d .,;\\\\[\\\\]-]+\" }\n];\n\nconst methodFullName=[];\nmethodFullName[\"HJ\"]=\"Метод Хука-Дживса\";\nmethodFullName[\"Swarm\"]=\"Метод частиц в стае\";\nmethodFullName[\"SA\"]=\"Метод имитации отжига\";\nmethodFullName[\"Genetic\"]=\"Генетический алгоритм\";\nmethodFullName[\"Tabu\"]=\"Метод табу-поиска\";\n\nconst optionsData=[\n  {id:\"HJ\", value:methodFullName[\"HJ\"]},\n  {id:\"Swarm\", value:methodFullName[\"Swarm\"]},\n  {id:\"SA\", value:methodFullName[\"SA\"]},\n  {id:\"Genetic\", value:methodFullName[\"Genetic\"]},\n  {id:\"Tabu\", value:methodFullName[\"Tabu\"]}\n];\n\nfunction App() {\n  var [plotState, setPlotState] = useState({\n    data: [],\n    layout: {}\n  });\n  var [results, setResults] = useState('');\n  var [method, setMethod] = useState(\"HJ\");\n  const inputRowList = rowsData.map(row =>\n    <InputRow key={row.id} id={row.id} name={row.name} pattern={row.pattern} sendData={sendData} required={row.required} />);\n  const optionsList = optionsData.map(item => \n    <option key={item.id} id={item.id}>{item.value}</option>);\n  function sendData(id, value) {\n    parametersList[id] = value;\n  }\n\n  function onSubmit(e) {\n    e.preventDefault();\n    if (CheckStringVector(parametersList[\"lowerBound\"])!==0){\n      alert(\"Error while parsing the lower bound\");\n      return;\n    }\n    if (CheckStringVector(parametersList[\"upperBound\"])!==0){\n      alert(\"Error while parsing the upper bound\");\n        return;\n    }\n    var returnedFromMethod = startOptimization(method, parametersList);\n    if (returnedFromMethod === -1){\n      alert(\"Error while parsing the function\");\n      return;\n    }\n    else{\n      if (returnedFromMethod===-2){\n        alert(\"Error while parsing the start point\");\n        return;\n      }\n    }\n    let checkedPoints = returnedFromMethod.checkedPoints,\n      functionIterations = returnedFromMethod.functionIterations,\n      xMin = returnedFromMethod.xMin,\n      fMin = returnedFromMethod.fMin,\n      DIM = returnedFromMethod.DIM,\n      functionValues = returnedFromMethod.functionValues,\n      methodTime = returnedFromMethod.methodTime/1000;\n    if (DIM <= 2) {\n      let X = returnedFromMethod.X,\n        Y = returnedFromMethod.Y,\n        checkedPointsT = returnedFromMethod.checkedPointsT,\n        labelsList = returnedFromMethod.labelsList;\n      for (let i = 0; i < functionValues.length; i++) {\n        if (!isFinite(functionValues[i])){\n          functionValues[i]=NaN;\n        }\n      }\n      let plotData = getPlot(X, Y, labelsList, checkedPointsT, xMin, fMin, DIM);\n      var newPlotState = {\n        data: plotData[0],\n        layout: plotData[1]\n      };\n    }\n    else {\n      var newPlotState = {\n        data: [],\n        layout: {}\n      };\n    }\n    //<textarea> filling\n    let s = \"\";\n    for (let i = 0; i < checkedPoints.length; i++) {\n      let stringVector = \"\";\n      for (const item of checkedPoints[i]) {\n        stringVector += item.toFixed(4) + ',';\n      }\n      stringVector = stringVector.slice(0, -2);//remove the last comma\n      s = s + i + ': (' + stringVector + '). ' + 'f=' + functionValues[i].toFixed(4) + '\\n';\n    }\n    let stringMinVector = \"\";\n    let j = 1;\n    for (const i in xMin) {\n      stringMinVector += xMin[i].toFixed(4) + ',';\n      if (j === DIM) {\n        break;\n      }\n      j++;\n    }\n    stringMinVector = stringMinVector.slice(0, -2);\n    let newResults = `${results}\\n${methodFullName[method]}\\n${s}x*=(${stringMinVector}), f(x*)=${fMin.toFixed(4)}\\nВычислений целевой функции: ${functionIterations}. Время выполнения: ${methodTime} секунд.\\n------`;\n    \n    setPlotState(newPlotState);\n    setResults(newResults);\n  }\n  return (\n    <div className=\"App\">\n      <div className=\"main section\">\n        <div className=\"solver section\">\n          <label htmlFor=\"solver\">Выберите метод:</label>\n          <select id=\"solver\" onChange={(event) => setMethod(event.target.selectedOptions[0].id)}>\n            {optionsList}\n          </select>\n        </div>\n        <form onSubmit={onSubmit}>\n        <div className=\"problem section\">\n          {inputRowList}\n        </div>\n        <Options method={method} sendData={sendData} />\n        \n          <div className=\"btn-submit section\">\n            <button id=\"btn-submit\">Старт</button>\n          </div>\n        </form>\n        <BrowserView>\n          <div className=\"plot section\">\n            <Plot data={plotState.data} layout={plotState.layout}\n              onInitialized={(figure) => setPlotState(figure)}\n              onUpdate={(figure) => setPlotState(figure)} />\n          </div>\n        </BrowserView>\n\n      </div>\n\n      <div className=\"results section\">\n        <textarea className=\"tbox\" readOnly value={results}>\n        </textarea>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}