{"version":3,"sources":["components/InputRow.js","components/Options.js","components/Constraints.js","modules/main.js","modules/plot.js","App.js","reportWebVitals.js","index.js"],"names":["InputRow","props","divId","id","className","htmlFor","name","required","pattern","autoComplete","onChange","e","sendData","target","value","Options","multistartOptionsList","map","data","saOptionsList","geneticOptionsList","saOptions","multistartOptions","geneticOptions","method","Constraints","DIM","math","create","all","EPS","parseStartPoint","startPointString","startPoint","match","length","i","parseFloat","intitializePoint","arr","x","x1","x2","x3","x4","x5","x6","x7","x8","x9","property","getValuesForPlot","objectiveFunction","lowerBound","upperBound","checkedPoints","getNumbersBetween","N","range","Array","step","Math","abs","idx","Y","X","Xi","push","point","j","sort","a","b","evaluate","coordsForContour","labelsList","checkedPointsT","createTree","objectiveFunctionString","node","parse","constants","Set","functions","symbols","traverse","isSymbolNode","add","isFunctionNode","has","setA","setB","difference","elem","delete","union","isStartPointCorrect","lb","ub","subtraction","r","Object","addition","multiplication","hookeJeeves","f","eps","deltaVector","lambda","alpha","yNext","xNext","y","functionIterations","values","slice","functionValues","assign","loop1","loop2","key","filter","item","xMin","fMin","DoubleSidedMap","keys","this","index","findIndex","it","getRandomInt","min","max","ceil","floor","random","geneticBinary","tMax","m","li","numbers","greys","grey","p","t","k","buildGrey","mapGrey","Creature","genotype","getValue","decode","g","gString","len","gS1","gString_","re","RegExp","parents","parentA","parentB","pA","pB","pA1","pA2","pB1","gsch1","gsch2","code","fenotype","chromosom","beta","priznak","h","getByKey","genotypeDecoded","gamma","getByValue","getMinimum","population","minValue","Number","MAX_SAFE_INTEGER","v","idxMin","getMaximum","maxValue","MIN_SAFE_INTEGER","idxMax","arrayContainsIn","mainArr","count","M","P","c","xk","xMax","fMax","step2","probabilityInterval","masterLoop","coin","childCandidate","containsIn","crossover","sch1","sch2","mutate","startOptimization","selectedMethodString","params","isNaN","forEach","replace","returned","size","symbols_sorted","from","symbols_new","dict","Map","set","transform","SymbolNode","get","console","log","toString","compile","error","parseFunction","returnedFromMethod","maxIter","parseInt","maxIterations","initialTemperature","endT","getProbability","E","T","exp","tossCoin","decreaseTemperature","candidateEnergy","currentEnergy","simulatedAnnealing","getPlot","Z","scatterData","type","line","color","text","textposition","mode","textfont","hoverinfo","contourData","scatterMinData","marker","symbol","z","contours","start","end","margin","hovermode","showlegend","parametersList","Plot","createPlotlyComponent","Plotly","rowsData","App","useState","layout","plotState","setPlotState","results","setResults","setMethod","inputRowList","row","onClick","onSubmit","preventDefault","plotData","newPlotState","s","stringVector","toFixed","stringMinVector","newResults","alert","onInitialized","figure","onUpdate","readOnly","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.cd998f6f.chunk.js","sourcesContent":["import \"../styles/InputRow.css\";\r\n\r\nfunction InputRow (props) {\r\n    function handleChange(e) {\r\n        props.sendData(props.id,e.target.value);\r\n    }\r\n    const divId=props.id+\"-container\";\r\n    return (\r\n        <div id={divId}>\r\n            <label className=\"row-label\" htmlFor={props.id}>{props.name}</label>\r\n            <input className=\"row-input\" id={props.id} required={props.required} pattern={props.pattern} \r\n            autoComplete=\"off\" onChange={handleChange}/>\r\n        </div>\r\n    );\r\n}\r\nexport default InputRow;","import InputRow from \"../components/InputRow\";\r\nfunction Options(props){\r\n    const saOptionsData=[\r\n        {id:\"startPoint\", name:\"Точка старта\",required:\"required\",pattern:\"[pie\\\\d .,;\\\\[\\\\]-]+\" },\r\n        {id:\"maxIterations\", name:\"Количество итераций\",required:\"required\",pattern:\"[1-9]\\\\d*\" },\r\n        {id:\"initialTemperature\",name:\"Начальная температура(>0)\",required:\"required\",pattern:\"[\\\\d .]+\"},\r\n        {id:\"c\",name:\"Параметр распределения Больцмана (>0)\",required:\"required\",pattern:\"[\\\\d .]+\"},\r\n        {id:\"beta\",name:\"Параметр уменьшения температуры [0.8;0.99]\",required:\"required\",pattern:\"[\\\\d .]+\"}\r\n    ];\r\n    const multistartOptionsData=[\r\n        {id:\"startPoint\", name:\"Точка старта\",required:\"required\",pattern:\"[pie\\\\d .,;\\\\[\\\\]-]+\" },\r\n        {id:\"deltaVector\", name:\"Вектор длин шагов\",required:\"required\",pattern:\"[pie\\\\d .,;\\\\[\\\\]-]+\" }, \r\n        {id:\"lambda\", name:\"Лямбда (Множитель шага >0)\",required:\"required\",pattern:\"[\\\\d. ]+\"},\r\n        {id:\"alpha\", name:\"Альфа (Коэф.уменьшения шага >1)\",required:\"required\",pattern:\"[\\\\d. ]+\"},\r\n        {id:\"eps\", name:\"Эпсилон(для остановки алгоритма >0)\",required:\"required\",pattern:\"[\\\\d. ]+\"}\r\n    ];\r\n    const geneticOptionsData=[\r\n        {id:\"maxIterations\", name:\"Количество итераций\",required:\"required\",pattern:\"[1-9]\\\\d*\" },\r\n        {id:\"m\", name:\"Объём популяции\",required:\"required\",pattern:\"[1-9]\\\\d*\" },\r\n        {id:\"li\", name:\"Длина кодирования гена\",required:\"required\",pattern:\"[1-9]\\\\d*\" }\r\n    ];\r\n    \r\n    const multistartOptionsList=multistartOptionsData.map(data=>\r\n        <InputRow key={data.id} id={data.id} name={data.name} pattern={data.pattern} required={data.required} sendData={props.sendData}/>);\r\n    const saOptionsList=saOptionsData.map(data=>\r\n        <InputRow key={data.id} id={data.id} name={data.name} pattern={data.pattern} required={data.required} sendData={props.sendData}/>);\r\n    const geneticOptionsList=geneticOptionsData.map(data=>\r\n        <InputRow key={data.id} id={data.id} name={data.name} pattern={data.pattern} required={data.required} sendData={props.sendData}/>);        \r\n    const saOptions=(\r\n        <div className=\"options section\">\r\n           {saOptionsList}\r\n        </div>\r\n    );\r\n    const multistartOptions=(\r\n        <div className=\"options section\">\r\n            {multistartOptionsList}\r\n        </div>\r\n    );\r\n    const geneticOptions=(\r\n        <div className=\"options section\">\r\n            {geneticOptionsList}\r\n        </div>\r\n    );\r\n    switch (props.method) {\r\n        case \"SA\":\r\n            return saOptions;\r\n        case \"Multistart\":\r\n            return multistartOptions;\r\n        case \"Genetic\":\r\n            return geneticOptions;\r\n        default:\r\n            break;\r\n    }\r\n}\r\nexport default Options;","import InputRow from \"../components/InputRow\";\r\nfunction Constraints(props){\r\n    const saConstraintsData=[\r\n        {id:\"SAconstraint\",name:\"SA Constraint\",required:\"\",pattern:\"\\\\d+\"},\r\n        {id:\"Aeq\",name:\"Aeq\",required:\"\",pattern:\"\\\\[[\\\\d ;.-]+\\\\]\"},\r\n        {id:\"Beq\",name:\"Beq\",required:\"\",pattern:\"\\\\[[\\\\d ;.-]+\\\\]\"}\r\n    ];\r\n    const MultistartConstraintsData=[\r\n        {id:\"Multistartconstraint\",name:\"Multistart Constraint\",required:\"\",pattern:\"\\\\d+\"},\r\n        {id:\"Aeq\",name:\"Aeq\",required:\"\",pattern:\"\\\\[[\\\\d ;.-]+\\\\]\"},\r\n        {id:\"Beq\",name:\"Beq\",required:\"\",pattern:\"\\\\[[\\\\d ;.-]+\\\\]\"}\r\n    ];\r\n\r\n    const MultistartConstraintsList=MultistartConstraintsData.map(data=>\r\n        <InputRow key={data.id} id={data.id} name={data.name} pattern={data.pattern} required={data.required} sendData={props.sendData}/>);\r\n    const saConstraintsList=saConstraintsData.map(data=>\r\n        <InputRow key={data.id} id={data.id} name={data.name} pattern={data.pattern} required={data.required} sendData={props.sendData}/>);\r\n    const saConstraints=(\r\n        <div className=\"constraints section\">\r\n            {saConstraintsList}\r\n        </div>\r\n    );\r\n    const MultistartConstraints=(\r\n        <div className=\"constraints section\">\r\n            {MultistartConstraintsList}\r\n        </div>\r\n    );\r\n    switch (props.method) {\r\n        case \"SA\":\r\n            return saConstraints;\r\n        case \"Multistart\":\r\n            return MultistartConstraints;\r\n        case \"Genetic\":\r\n            return MultistartConstraints;\r\n        default:\r\n            break;\r\n    }\r\n}\r\nexport default Constraints;","import {create,all, norm, min} from \"mathjs\";\r\nconst math = create({\r\n    all\r\n});\r\nvar DIM;\r\nconst EPS=1e-8;\r\nfunction parseStartPoint(startPointString) {\r\n    let re=/[\\w.-]+/g;\r\n    let startPoint=startPointString.match(re);\r\n    if (startPoint.length !== DIM){\r\n        return -2;\r\n    }\r\n    for (let i = 0; i < DIM; i++) {\r\n        startPoint[i] = parseFloat(startPoint[i]);\r\n    }\r\n    return startPoint;\r\n}\r\nfunction intitializePoint(arr){\r\n    let x = {x1:0,x2:0,x3:0,x4:0,x5:0,x6:0,x7:0,x8:0,x9:0};\r\n    let i = 0;\r\n    for (const property in x) {\r\n        x[property] = arr[i++];\r\n        if (i === DIM){\r\n            break;\r\n        }\r\n    }\r\n    return x;\r\n}\r\nfunction isEqualitiesSatisfied(x,Aeqs,Beqs){\r\n    for (let i=0;i<Aeqs.length;i++) {\r\n        let e = Aeqs[i].evaluate(x);\r\n        if (Math.abs(e-Beqs[i])<EPS){ // e<=beqs[i]\r\n            return true;\r\n        }\r\n        else{\r\n            return false;\r\n        }\r\n    }\r\n}\r\nfunction isBoundariesSatisfied(xi,lb,ub) {\r\n    if (xi < lb-EPS || xi> ub+EPS){return false;}\r\n    else{return true;}\r\n}\r\nfunction hookeJeevesMultistart (x,maxIter,f,lowerBound,upperBound,eps) {\r\n    let checkedPoints = [Object.values(x).slice(0,DIM)];\r\n    let fMin = f.evaluate(x);\r\n    let functionIterations = 1;\r\n    let functionValues=[fMin];\r\n    let xMin = Object.assign({},x);\r\n    let d = 1;\r\n    let y=fMin;\r\n    let i=0;\r\n    while ((d > eps) && (i < maxIter)) {\r\n        let fl=false;\r\n        let i = 0;\r\n        for (const property in x) {\r\n            let xi = x[property];\r\n            \r\n            let sign = 1;\r\n            //j<2 to check left and right \r\n            for (let j = 0; j<2;j++) {   \r\n                if (j!==0) {\r\n                    sign=-1;\r\n                }\r\n                xi=xi+sign*d;\r\n                if(!isBoundariesSatisfied(xi,lowerBound[i],upperBound[i])){\r\n                    xi=xi-sign*d;continue;\r\n                }\r\n                x[property] = xi;\r\n                /*if(Aeqs != undefined && Beqs != undefined){\r\n                    if (!isEqualitiesSatisfied(x,Aeqs,Beqs)){\r\n                        x[property] = xi-sign*d;\r\n                        continue;\r\n                    }\r\n                }*/\r\n                let fX=f.evaluate(x);\r\n                functionIterations++;\r\n                if (fX < y){\r\n                    y=fX;\r\n                    fl=true;\r\n                    xMin=Object.assign({},x);\r\n                    fMin=fX;\r\n                    checkedPoints.push(Object.values(xMin).slice(0,DIM));\r\n                    functionValues.push(fMin);\r\n                }\r\n                else{\r\n                    xi=xi-sign*d;\r\n                    if(!isBoundariesSatisfied(xi,lowerBound[i],upperBound[i])){\r\n                        xi=xi+sign*d;continue;\r\n                    }\r\n                    x[property] = xi;\r\n                    /*if(Aeqs != undefined && Beqs !=undefined){\r\n                        if (!isEqualitiesSatisfied(x,Aeqs,Beqs)){\r\n                            x[property] = xi-sign*d;\r\n                            continue;\r\n                        }\r\n                    }*/\r\n                }\r\n            }           \r\n            i++;\r\n            if (i >= DIM){\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (fl===false){\r\n            d=d/2;\r\n        }\r\n    }\r\n    return [checkedPoints,functionIterations,xMin,fMin,functionValues];\r\n}\r\n\r\nfunction simulatedAnnealing(initialTemperature,endT,maxIter,x,f,lowerBound,upperBound){\r\n    function getProbability(E,T) { return Math.exp(-E/T); }\r\n    function tossCoin(p){\r\n        if (Math.random() < p + 1e-8) { return true; }\r\n        else { return false; } \r\n    }\r\n    function decreaseTemperature(T,i) { return T*0.1/i; }\r\n    function getRandomBetween(min, max) { return Math.random() * (max - min) + min; }\r\n    let checkedPoints=[Object.values(x).slice(0,DIM)];\r\n    let functionIterations = 0;\r\n    let candidateEnergy, p;\r\n    let T=initialTemperature, currentEnergy=f.evaluate(x);\r\n    functionIterations++;\r\n    let xMin=x,fMin=currentEnergy;\r\n    let functionValues=[fMin];\r\n    for (let i = 0; i<maxIter;i++) {  \r\n        let i = 0;\r\n        for (const property in x) {\r\n            /*if(Aeqs != undefined && Beqs !=undefined){\r\n                do {\r\n                    x[property]=getRandomBetween(lowerBound[i], upperBound[i]);\r\n                } while (!isEqualitiesSatisfied(x,Aeqs,Beqs) && Aeqs != undefined && Beqs !=undefined);\r\n            }*/\r\n            //else{\r\n                x[property]=getRandomBetween(lowerBound[i], upperBound[i]);\r\n            //}\r\n            i++;\r\n            if (i >= DIM){\r\n                break;\r\n            }\r\n        }\r\n        candidateEnergy = f.evaluate(x);\r\n        functionIterations++;\r\n        if (candidateEnergy<currentEnergy-1e-8){\r\n            currentEnergy=candidateEnergy;\r\n            xMin=Object.assign({},x);\r\n            fMin=currentEnergy;\r\n            checkedPoints.push(Object.values(xMin).slice(0,DIM));\r\n            functionValues.push(fMin);\r\n        }\r\n        else {\r\n            p=getProbability(candidateEnergy-currentEnergy,T);\r\n            if (tossCoin(p)===true){\r\n                currentEnergy=candidateEnergy;\r\n                xMin=Object.assign({},x);\r\n                fMin=currentEnergy;\r\n                checkedPoints.push(Object.values(xMin).slice(0,DIM));\r\n                functionValues.push(fMin);\r\n            }\r\n        }\r\n        T=decreaseTemperature(initialTemperature,i);\r\n        if (T < endT+1e-8){\r\n            break;\r\n        }\r\n    }\r\n    return [checkedPoints,functionIterations,xMin,fMin,functionValues];\r\n}\r\n\r\nfunction coordsForContour(lowerBound,upperBound,objectiveFunction,checkedPoints){\r\n    function getNumbersBetween(lowerBound,upperBound,N){\r\n        var range = new Array(N);\r\n        var step = Math.abs((upperBound-lowerBound))/N;\r\n        var idx = 0;\r\n        for (let i = lowerBound; i < upperBound - 1e-8; i+=step) {\r\n            range[idx] = i;\r\n            idx++;\r\n        }\r\n        return range;\r\n    }\r\n    var N = 100; //quantity\r\n    var X = [];\r\n    var Y;\r\n    for (let i = 0; i < DIM; i++) {\r\n        let Xi = getNumbersBetween(lowerBound[i], upperBound[i], N);\r\n        X.push(Xi);\r\n    }\r\n    \r\n    for (const point of checkedPoints) {\r\n        for (let j = 0; j < DIM; j++) {\r\n            X[j].push(point[j]);\r\n        }\r\n    }\r\n    for (let i = 0; i < DIM; i++) {\r\n        X[i].sort(function(a,b){\r\n            return a-b;\r\n        });\r\n    }\r\n    N+=checkedPoints.length;\r\n    if (DIM === 2){\r\n        Y = new Array(N);\r\n        for (let i = 0; i < N; i++) {\r\n            Y[i]=new Array(N);\r\n        }\r\n        for (let i = 0; i < N; i++) {\r\n            for (let j = 0; j < N; j++) {\r\n                let x = {x1:X[0][i], x2: X[1][j]};\r\n                Y[j][i]=objectiveFunction.evaluate(x);//rows - Yaxis, cols - Xaxis in plotly contour\r\n            }\r\n        }\r\n    }\r\n    else{\r\n        Y = [];\r\n        for (let i = 0; i < N; i++) {\r\n            let x = {x1:X[0][i]};\r\n            Y.push(objectiveFunction.evaluate(x));//rows - Yaxis, cols - Xaxis in plotly contour\r\n        }\r\n    }\r\n    return [X,Y];\r\n}\r\n\r\nfunction getValuesForPlot(objectiveFunction,lowerBound,upperBound,checkedPoints){\r\n    let [X,Y]=coordsForContour(lowerBound,upperBound,objectiveFunction,checkedPoints);\r\n    let labelsList = [];\r\n    for (let i = 0; i <= checkedPoints.length; i++) {\r\n        labelsList.push(i);\r\n    }\r\n    //checkedPoints transposed\r\n    var checkedPointsT=[];\r\n    for(let i = 0; i < DIM; i++) {\r\n        checkedPointsT[i] = new Array(checkedPoints.length);\r\n    }\r\n\r\n    for (let i = 0; i < checkedPoints.length; i++) {\r\n        let point = checkedPoints[i];\r\n        for (let j = 0; j < DIM; j++) {\r\n            checkedPointsT[j][i] = point[j];\r\n        }\r\n    }\r\n    //compute function values on the search line\r\n    if (DIM === 1){\r\n        checkedPointsT[1] = new Array(checkedPointsT[0].length);\r\n        for (let i = 0; i < checkedPointsT[0].length; i++) {\r\n            checkedPointsT[1][i] = objectiveFunction.evaluate({x1: checkedPointsT[0][i]});\r\n        }\r\n    }\r\n    return [X,Y,checkedPointsT,labelsList];   \r\n}\r\n//difference = set - subset\r\nfunction difference(setA,setB){\r\n    let difference = new Set(setA);\r\n    for (let elem of setB){\r\n        if (difference.has(elem)){\r\n            difference.delete(elem);\r\n        }\r\n    }\r\n    return difference;\r\n}\r\nfunction union(setA, setB) {\r\n    let union = new Set(setA)\r\n    for (let elem of setB) {\r\n        union.add(elem)\r\n    }\r\n    return union\r\n}\r\n\r\nfunction createTree(objectiveFunctionString) {\r\n    var node = math.parse(objectiveFunctionString);\r\n    var constants = new Set(['pi','e','E','i','PI']);\r\n    var functions = new Set(['sin','cos','tan','cot','exp','abs','sqrt','sign','log',\r\n        'log10','log2','nthRoot','acos','acot','asin','atan','sec','norm']);\r\n    var symbols = new Set();\r\n    node.traverse(function (node) {\r\n        if (node.isSymbolNode) {\r\n            symbols.add(node.name);\r\n        }\r\n        else if (node.isFunctionNode && functions.has(node.name)) {\r\n            functions.add(node.name);\r\n        }\r\n    });\r\n    symbols = difference(symbols,union(constants,functions));\r\n    return [node,symbols];\r\n}\r\n\r\nfunction parseFunction(objectiveFunctionString,DIM) {\r\n    let c = new Set(['pi','e','E','i','PI','sin','cos','tan','cot','exp','abs','sqrt','sign','log',\r\n    'log10','log2','nthRoot','acos','acot','asin','atan','sec','norm']);\r\n    try {\r\n        //mapping \"(\" -> \"*(\"\r\n        let re=/[\\w.]+(?=\\()/g;\r\n        let r=objectiveFunctionString.match(re);\r\n        if (r !== null){\r\n            r=r.filter(item => !c.has(item));\r\n            r.forEach(t => {\r\n                objectiveFunctionString=objectiveFunctionString.replace(t,t+'*');\r\n            });\r\n        }\r\n        let returned = createTree(objectiveFunctionString);\r\n        let node = returned[0];\r\n        let symbols = returned[1];\r\n        if (symbols.size !== DIM) { throw \"Несоответствие размерностей целевой функции и стартовой точки.\";}\r\n        //renaming variables to the hardcoded names\r\n        let symbols_sorted=Array.from(symbols).sort();\r\n        let symbols_new=['x1','x2','x3','x4','x5','x6','x7','x8','x9'];\r\n        if (symbols_sorted !== symbols_new){\r\n            let dict=new Map();\r\n            for (let i = 0; i < symbols_sorted.length; i++) {\r\n                dict.set(symbols_sorted[i],symbols_new[i]);\r\n            }\r\n            node = node.transform(function (node) {\r\n                if (node.isSymbolNode && symbols.has(node.name)) {\r\n                    return new math.SymbolNode(dict.get(node.name));\r\n                }\r\n                else {\r\n                    return node;\r\n                }\r\n            });\r\n        }\r\n        console.log(node.toString());\r\n        /*node.traverse(function (node) {\r\n            var chck = node.isFunctionNode;\r\n            console.log(node.type, node.op, node.value,node.name,chck);\r\n        });*/\r\n        let compiled_node=node.compile();\r\n        return compiled_node;\r\n    }\r\n    catch (error) {\r\n        return -1;\r\n    }\r\n}\r\nfunction isStartPointCorrect(startPoint,lb,ub) {\r\n    for (let i = 0; i < DIM; i++) {\r\n        if (startPoint[i] > ub[i] || startPoint[i] < lb[i]){\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction somemethod(f,intervalsList,maxIter,lowerBound,upperBound,N) {\r\n    function createGrid(intervalsList,N) {\r\n        let newIntervalsList=new Array(DIM);\r\n        //newIntervalsList: 0 - [a11=a1,a12,...,a1N=b1], ...\r\n        //intervalsList: 0 - [a1,b1], 1 - [a2,b2], ...\r\n        for (let i = 0; i < DIM; i++) {\r\n            newIntervalsList[i]=new Array(N+1);\r\n            let a = intervalsList[i][0],b = intervalsList[i][1];\r\n            let step = (b - a)/N;\r\n            let j=0;\r\n            while (j < N + 1){\r\n                newIntervalsList[i][j++]=a;\r\n                a+=step;\r\n            }\r\n        }\r\n        //grid = transposed newIntervalsList\r\n        //grid: 0: [a11,a21,a31,...,aDIM1], 1: [a12,a22,a32,...]\r\n        let grid=new Array(N+1);\r\n        for (let i = 0; i < N+1; i++) {\r\n            grid[i]=new Array(DIM);\r\n            for (let j = 0; j < DIM; j++) {\r\n                grid[i][j]=newIntervalsList[j][i];\r\n            }\r\n        }\r\n        return grid;\r\n    }\r\n    let functionIterations=0;\r\n    let grid = createGrid(intervalsList,N);\r\n    let xMin,fMin=Number.MAX_SAFE_INTEGER;\r\n    for (let i = 0; i < grid.length; i++) {\r\n        let startPoint=intitializePoint(grid[i]);\r\n        var returnedFromMethod = hookeJeeves(startPoint,maxIter,f,lowerBound,upperBound);\r\n        functionIterations+=returnedFromMethod[1];\r\n        let xMinCanditate=returnedFromMethod[2],fMinCanditate=returnedFromMethod[3];\r\n        if (fMinCanditate < fMin){\r\n            fMin = fMinCanditate;\r\n            xMin = xMinCanditate;\r\n            var checkedPoints=returnedFromMethod[0];\r\n        }\r\n    }\r\n    return [checkedPoints,functionIterations,xMin,fMin];\r\n}\r\nfunction subtraction(a,b) {\r\n    let r = Object.create(a);\r\n    for (const property in a) {\r\n        r[property]=a[property]-b[property];\r\n    }\r\n    return r;\r\n}\r\nfunction addition(a,b) {\r\n    let r = Object.create(a);\r\n    for (const property in a) {\r\n        r[property]=a[property]+b[property];\r\n    }\r\n    return r;\r\n}\r\nfunction multiplication(a,b) {\r\n    let r = Object.create(b);\r\n    if (typeof a === \"number\"){\r\n        for (const property in b) {\r\n            r[property] = a*b[property];\r\n        }\r\n    }\r\n    else{\r\n        for (const property in a) {\r\n            r[property]=a[property]*b[property];\r\n        }\r\n    }\r\n    return r;\r\n}\r\nfunction division(a,b) {\r\n    let r = Object.create(a);\r\n    for (const property in a) {\r\n        r[property]=a[property]/b[property];\r\n    }\r\n    return r;\r\n}\r\nfunction tunnel(x,f,eps,deltaVector,lambda,alpha) {\r\n    function createStartPoints(xRecord) {\r\n        let X=[];\r\n        let x=Object.assign({},xRecord);\r\n        let i=1;\r\n        for (const property in xRecord) {\r\n            x[property]=xRecord[property]+gamma;\r\n            X.push(Object.assign({},x));\r\n            x[property]=xRecord[property]-gamma;\r\n            X.push(Object.assign({},x));\r\n            x[property]=xRecord[property]+gamma/2;\r\n            X.push(Object.assign({},x));\r\n            x[property]=xRecord[property]-gamma/2;\r\n            X.push(Object.assign({},x));\r\n            if (i===DIM){\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n        return X;\r\n    }\r\n    let gamma=1;\r\n    let [functionIterations,xRecord,fxRecord] = hookeJeeves(x,f,eps,deltaVector,lambda,alpha);\r\n    let X=createStartPoints(xRecord);\r\n    let checkedPoints=[];\r\n    checkedPoints.push(Object.values(x).slice(0,DIM));\r\n    checkedPoints.push(Object.values(xRecord).slice(0,DIM));\r\n    if (fxRecord < 0){\r\n        var r=2*Math.abs(fxRecord);\r\n    }\r\n    else{\r\n        var r=fxRecord;\r\n    }\r\n    let b=1;\r\n    let k=1,K=100;\r\n    mainLoop: for(;;){\r\n        //туннельная фаза\r\n        step3: for(;;){\r\n            let s = `[${Object.values(xRecord).toString()}]`;\r\n            let tunnelFunctionString = `1/(${r}+${fxRecord})*exp(-norm(subtract([x1,x2,x3,x4,x5,x6,x7,x8,x9],${s}))/${b})`;\r\n            let tunnelFunction=math.compile(tunnelFunctionString);\r\n            for (const item of X) {\r\n                let mI,fI;\r\n                var z,fz;\r\n                [fI,z,fz]=hookeJeeves(item,tunnelFunction,eps,deltaVector,lambda,alpha);\r\n                functionIterations+=fI;\r\n                functionIterations++;\r\n                if (f.evaluate(z) < fxRecord + EPS){\r\n                    break step3;\r\n                }\r\n            }\r\n            //step 8\r\n            r/=1.2;\r\n            k++;\r\n            if (k> K){\r\n                var xMin=xRecord;\r\n                var fMin=fxRecord;\r\n                break mainLoop;\r\n            }\r\n        }\r\n        //step 4: фаза минимизации\r\n        checkedPoints.push(Object.values(z).slice(0,DIM));\r\n        let [fI,zRecord,fzRecord]=hookeJeeves(z,f,eps,deltaVector,lambda,alpha);\r\n        functionIterations+=fI;\r\n        if (fzRecord < fxRecord + EPS){\r\n            xRecord=Object.assign({},zRecord);\r\n            fxRecord=fzRecord;\r\n            X=createStartPoints(xRecord);\r\n            checkedPoints.push(Object.values(xRecord).slice(0,DIM));\r\n            continue mainLoop;\r\n        }\r\n        else{\r\n            if(k < K){\r\n                r*=1.8;\r\n                b*=1.1;\r\n                let delta=1;\r\n                let zR=Object.values(zRecord);\r\n                let xR=Object.values(xRecord);\r\n                let subt = math.subtract(zR,xR);\r\n                let tx0=xR+delta*subt/norm(subt);\r\n                let x0=Object.assign(xRecord);\r\n                let i=0;\r\n                for (const property in x0) {\r\n                    x0[property]=tx0[i++];\r\n                }\r\n                X=[x0];\r\n                checkedPoints.push(Object.values(x0).slice(0,DIM));\r\n                continue mainLoop;\r\n            }\r\n            else{\r\n                var xMin=xRecord;\r\n                var fMin=fxRecord;\r\n                break mainLoop;\r\n            }\r\n        }\r\n    }\r\n    return [checkedPoints,functionIterations,xMin,fMin];\r\n}\r\nfunction hookeJeeves(x,f,eps,deltaVector,lambda,alpha) {\r\n    let y = x,i=1,yNext,xNext;\r\n    let functionIterations=0;\r\n    let checkedPoints=[(Object.values(y).slice(0,DIM))];\r\n    let functionValues=[f.evaluate(y)];\r\n    yNext = Object.assign({},y);\r\n    loop1: for(;;) {\r\n        loop2: for (const key in y) {\r\n            //step 2a\r\n            yNext[key]+=deltaVector[i-1];\r\n            functionIterations+=2;\r\n            if (f.evaluate(yNext) < f.evaluate(y) - EPS){\r\n                y = Object.assign({},yNext);\r\n                checkedPoints.push((Object.values(y).slice(0,DIM)));\r\n                functionValues.push(f.evaluate(y));\r\n            }\r\n            else{//step 2b\r\n                yNext[key]=yNext[key]-2*deltaVector[i-1];//cancel addition on the step2a\r\n                functionIterations+=2;\r\n                if (f.evaluate(yNext) < f.evaluate(y) - EPS){\r\n                    y = Object.assign({},yNext);\r\n                    checkedPoints.push((Object.values(y).slice(0,DIM)));\r\n                    functionValues.push(f.evaluate(y));\r\n                }\r\n                else{\r\n                    yNext = Object.assign({},y);\r\n                }\r\n            }\r\n            //step 3a\r\n            if (i < DIM){\r\n                i++;\r\n                continue loop2;\r\n            }\r\n            //step 3b\r\n            if (i===DIM){\r\n                //step 4\r\n                functionIterations+=2;\r\n                if (f.evaluate(yNext) < f.evaluate(x) - EPS){\r\n                    xNext = Object.assign({},yNext);\r\n                    y=addition(xNext,multiplication(lambda,(subtraction(xNext,x))));\r\n                    x=Object.assign({},xNext);\r\n                    yNext=Object.assign({},y);\r\n                    checkedPoints.push((Object.values(y).slice(0,DIM)));\r\n                    functionValues.push(f.evaluate(y));\r\n                    i=1;\r\n                    break loop2;\r\n                }\r\n                else{//step 5a\r\n                    let r = deltaVector.filter(item=>item<eps+EPS);\r\n                    if (r.length === deltaVector.length){\r\n                        var xMin=Object.assign({},x);\r\n                        functionIterations++;\r\n                        var fMin=f.evaluate(x);\r\n                        break loop1;\r\n                    }\r\n                    else{//step 5b\r\n                        for (let i = 0; i < deltaVector.length; i++) {\r\n                            if (deltaVector[i]> eps + EPS){\r\n                                deltaVector[i]/=alpha;\r\n                            }\r\n                        }\r\n                        y = Object.assign({},x);\r\n                        yNext=Object.assign({},x);\r\n                        x = Object.assign({},xNext);\r\n                        i=1;\r\n                        break loop2;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return [checkedPoints,functionIterations,xMin,fMin,functionValues];\r\n}\r\n\r\n\r\nclass DoubleSidedMap{\r\n  constructor(keys,values){\r\n    this.keys=keys;\r\n    this.values=values;\r\n  }\r\n  getByKey(key){\r\n  const index = this.keys.findIndex(it => it === key);\r\n  \treturn this.values[index];\r\n  }\r\n  getByValue(value){\r\n  \tconst index = this.values.findIndex(it => it === value);\r\n  \treturn this.keys[index];\r\n  }\r\n}\r\nfunction getRandomInt(min,max){\r\n    min = Math.ceil(min);\r\n    max = Math.floor(max);\r\n    return Math.floor(Math.random() * (max - min) + min);\r\n}\r\nfunction buildGrey(li) {\r\n    let grey=new Array(2**li);\r\n    grey[0]=\"0\";\r\n    grey[1]=\"1\";\r\n    let p=2;\r\n    for (let i = 2; i <= li; i++) {\r\n        let t=p-1;\r\n        p*=2;\r\n        for (let k = Math.floor(p/2); k < p; k++) {\r\n            grey[k]=grey[t];\r\n            grey[t]=\"0\"+grey[t];\r\n            grey[k]=\"1\"+grey[k];\r\n            t--;\r\n        }\r\n    }\r\n    return grey;\r\n}\r\nfunction geneticBinary(tMax,m,f,lb,ub,li) {\r\n    let numbers=new Array(2**li);\r\n    for (let i = 0; i < 2**li; i++) {\r\n        numbers[i]=i;\r\n    }\r\n    let greys=buildGrey(li);\r\n    let mapGrey=new DoubleSidedMap(numbers,greys);\r\n    let k=2**li-1;\r\n    class Creature {\r\n        constructor(genotype){\r\n            this.genotype=genotype;\r\n            this.value=getValue(decode(genotype));\r\n        }\r\n        static crossover(parents){ //одноточечное скрещивание\r\n            let parentA=parents[0].genotype,parentB=parents[1].genotype;\r\n            //parentA=[\"1110\",\"1000\",\"1010\"], B=[\"0001\",\"0100\",\"0101\"] 1..DIM\r\n            //\"111010001010\"->\"111.010001010\"->\"111101000101\"->\"1111,0100,0101\"\r\n            //\"000101000101\"->\"000.101000101\"->\"000010001010\"->\"0000,1000,1010\"\r\n            let pA=\"\",pB=\"\";\r\n            for (let i = 0; i < DIM; i++) {\r\n                pA+=parentA[i];\r\n                pB+=parentB[i];\r\n            }\r\n            let len = pA.length;\r\n            let idx = getRandomInt(1,len);\r\n            let pA1=pA.slice(0,idx), pA2=pA.slice(idx,len);\r\n            let pB1=pB.slice(0,idx), pB2=pB.slice(idx,len);\r\n            let gsch1=pA1+pB2;\r\n            let gsch2=pB1+pA2;\r\n            let re=new RegExp(`\\\\d{${li}}`,`g`);\r\n            gsch1=gsch1.match(re);\r\n            gsch2=gsch2.match(re);\r\n            let sch1=new Creature(gsch1), sch2=new Creature(gsch2);\r\n            return [sch1,sch2];\r\n        }\r\n        mutate(){ //инверсия\r\n            let g=this.genotype;\r\n            let gString=\"\";\r\n            for (let i = 0; i < DIM; i++) {\r\n                gString+=g[i];\r\n            }\r\n            let len = gString.length;\r\n            let idx = getRandomInt(1,len);\r\n            let gS1=gString.slice(0,idx), gS2=gString.slice(idx,len);\r\n            let gString_ = gS2+gS1;\r\n            let re=new RegExp(`\\\\d{${li}}`,`g`);\r\n            this.genotype=gString_.match(re);\r\n            this.value=getValue(decode(this.genotype));\r\n        }\r\n        containsIn(arr){\r\n            for (const i of arr) {\r\n                if (i.genotype===this.genotype){\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n    function code(fenotype){\r\n         let genotype=new Array(DIM);\r\n         //fenotype=[p1,p2,..,pn] -> genotype=[\"1010\",\"1111\",...,\"1100\"]\r\n         //priznak=pi\r\n         //chromosom=\"abcd\"\r\n         for (let i = 0; i < DIM; i++) {\r\n            let chromosom,beta;\r\n            let priznak=fenotype[i];\r\n            if (Math.abs(priznak-lb[i])<EPS){\r\n                beta = 0;\r\n            }\r\n            else{\r\n                let h = (ub[i]-lb[i])/(k-1);\r\n                beta = Math.floor((priznak-lb[i])/h)+1;//номер признака\r\n                chromosom=mapGrey.getByKey(beta);\r\n            }\r\n            genotype[i]=chromosom;\r\n         }\r\n         return genotype;\r\n    }\r\n    function decode(genotype) {\r\n        let genotypeDecoded=new Array(DIM);\r\n        for (let i = 0; i < DIM; i++) {\r\n            let priznak;\r\n            let gamma=mapGrey.getByValue(genotype[i]);\r\n            if (gamma === 0){\r\n                priznak=lb[i];\r\n            }\r\n            else{\r\n                if (gamma === k){\r\n                    priznak=ub[i];\r\n                }\r\n                else{\r\n                    let h = (ub[i]-lb[i])/(k-1);\r\n                    priznak=((lb[i]+(gamma-1)*h)+(lb[i]+gamma*h))/2;\r\n                }\r\n            }\r\n            genotypeDecoded[i]=priznak;\r\n        }\r\n        return genotypeDecoded;\r\n    }\r\n    function getValue(g){\r\n        let x=intitializePoint(g);\r\n        let fx=-f.evaluate(x);\r\n        return fx;\r\n    }\r\n    function getMinimum(population){\r\n        let minValue=Number.MAX_SAFE_INTEGER;\r\n        for (let i = 0; i < m; i++) {\r\n            let v = population[i].value;\r\n            if (v < minValue-EPS){\r\n                var idxMin=i;\r\n                minValue=v;\r\n            }\r\n        }\r\n        return idxMin;\r\n    }\r\n    function getMaximum(population){\r\n        let maxValue=Number.MIN_SAFE_INTEGER;\r\n        for (let i = 0; i < m; i++) {\r\n            let v = population[i].value;\r\n            if (v-EPS > maxValue){\r\n                var idxMax=i;\r\n                maxValue=v;\r\n            }\r\n        }\r\n        return idxMax;\r\n    }\r\n    function arrayContainsIn(mainArr,arr) {\r\n        for (const it of mainArr) {\r\n            let count=0;\r\n            for (let i = 0; i < it.length; i++) {\r\n                if (Math.abs(it[i]-arr[i])<EPS){\r\n                    count++;\r\n                }\r\n            }\r\n            if (count === arr.length){\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    let t=0,M=1;\r\n    //шаг 1 начальная популяция\r\n    let P=new Array(m);\r\n    let population = new Array(m);\r\n    let sumOfValues=0;\r\n    let functionIterations=m,checkedPoints=[],functionValues=[];\r\n    for (let i = 0; i < m; i++) {\r\n        P[i]=new Array(DIM);\r\n        for (let j = 0; j < DIM; j++) {\r\n            P[i][j]=(ub[j]-lb[j])*Math.random()+lb[j];\r\n        }\r\n        let fenotype=P[i];\r\n        let genotype=code(fenotype);\r\n        let c = new Creature(genotype);\r\n        sumOfValues+=c.value;\r\n        population[i]=c;\r\n    }\r\n    let idxMax=getMaximum(population);\r\n    let xk=decode(population[idxMax].genotype);\r\n    var xMax=intitializePoint(xk);\r\n    var fMax=f.evaluate(xMax);\r\n    if (!arrayContainsIn(checkedPoints,xk)){\r\n        checkedPoints.push(xk);\r\n        functionValues.push(fMax);\r\n    }\r\n    /*let probabilities=new Array(m+1);\r\n    probabilities[0]=0;\r\n    for (let i = 1; i < m+1; i++) {\r\n        probabilities[i]=probabilities[i-1]+population[i-1].value/sumOfValues;\r\n    }*/\r\n    //шаг 2. селекция\r\n    step2: for(;;){\r\n        let probabilityInterval=new Array(m+1);\r\n        let parents=[];\r\n        probabilityInterval[0]=0;\r\n        for (let i = 1; i < m+1; i++) {\r\n            probabilityInterval[i]=probabilityInterval[i-1]+1/m; //панмиксия\r\n        }\r\n        masterLoop: for (;;){\r\n            let coin = Math.random();\r\n            slaveLoop: for (let i = 1; i < m+1; i++) {\r\n                if (probabilityInterval[i-1] < coin && coin < probabilityInterval[i]){\r\n                    let childCandidate=population[i-1];\r\n                    if (!childCandidate.containsIn(parents)){\r\n                        parents.push(childCandidate);\r\n                        if(parents.length === 2){\r\n                            break masterLoop;\r\n                        }\r\n                        else{\r\n                            continue masterLoop;\r\n                        }\r\n                    }\r\n                    else{\r\n                        continue masterLoop;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        //шаг 3 скрещивание\r\n        let [sch1,sch2]=Creature.crossover(parents);\r\n        sch1.mutate();\r\n        sch2.mutate();\r\n        functionIterations+=2;\r\n        let idxMin=getMinimum(population);\r\n        let coin = Math.random();\r\n        if (coin-EPS > 0.5){\r\n            population[idxMin]=sch1;\r\n        }\r\n        else{\r\n            population[idxMin]=sch2;\r\n        }\r\n        let idxMax=getMaximum(population);\r\n        let xk=decode(population[idxMax].genotype);\r\n        var xMax=intitializePoint(xk);\r\n        var fMax=f.evaluate(xMax);\r\n        if (!arrayContainsIn(checkedPoints,xk)){\r\n            checkedPoints.push(xk);\r\n            functionValues.push(fMax);\r\n        }\r\n        if (M < m){\r\n            M++;\r\n            continue step2;\r\n        }\r\n        if (M===m){\r\n            t++;\r\n        }\r\n        if (t===tMax){\r\n            idxMax=getMaximum(population);\r\n            xk=decode(population[idxMax].genotype);\r\n            xMax=intitializePoint(xk);\r\n            fMax=f.evaluate(xMax);\r\n            if (!arrayContainsIn(checkedPoints,xk)){\r\n                checkedPoints.push(xk);\r\n                functionValues.push(fMax);\r\n            }\r\n            break step2;\r\n        }\r\n        else{\r\n            M=1;\r\n            continue step2;\r\n        }\r\n    }\r\n    let xMin=xMax,fMin=fMax;\r\n    return [checkedPoints,functionIterations,xMin,fMin,functionValues];\r\n}\r\nfunction startOptimization(selectedMethodString,params){\r\n    let objectiveFunctionString=params.objectiveFunction;\r\n    /*if (params.Aeq !== undefined || params.Beq !== undefined){\r\n        var Aeq=params.Aeq;\r\n        var Beq=params.Beq;\r\n    }*/\r\n    let re=/[\\w.-]+/g;\r\n    let lowerBound=params.lowerBound.match(re);\r\n    let upperBound=params.upperBound.match(re);\r\n    DIM = lowerBound.length; \r\n    for (let i = 0; i < DIM; i++) {\r\n        lowerBound[i] = parseFloat(lowerBound[i]);\r\n        upperBound[i] = parseFloat(upperBound[i]);\r\n        if (isNaN(lowerBound[i])){\r\n            lowerBound[i]=Number.MIN_SAFE_INTEGER;\r\n        }\r\n        if (isNaN(upperBound[i])){\r\n            upperBound[i]=Number.MAX_SAFE_INTEGER;\r\n        }\r\n    }\r\n    /*if (params.Aeq !== undefined || params.Beq !== undefined){\r\n        let xKeys=[\"x1\",\"x2\",\"x3\",\"x4\",\"x5\",\"x6\",\"x7\",\"x8\",\"x9\"];\r\n        Aeq=Aeq.substring(1,Aeq.length-1).split(';');\r\n        Beq=Beq.substring(1,Beq.length-1).split(';');\r\n        if (Aeq.length !== Beq.length){return -1;}\r\n        var Aeqs=[];\r\n        for (let i=0;i<Aeq.length;i++){\r\n            let t = Aeq[i].match(/-?\\d+\\.\\d+|-?\\d+/g);\r\n            let s=\"\";\r\n            for (let idx=0;idx<t.length;idx++) { \r\n                if (t[idx].charAt(0)!=='-'){s = s+'+'+t[idx]+'*'+xKeys[idx];}\r\n                else {s = s+t[idx]+'*'+xKeys[idx];}\r\n            }\r\n            if (s.charAt(0)==='+'){\r\n                s=s.substring(1,s.length);\r\n            }\r\n            let e = math.parse(s).toString();\r\n            Aeqs.push(math.compile(s));\r\n        }\r\n        var Beqs=[];\r\n        for (let i = 0; i < Beq.length; i++) {\r\n            Beqs.push(parseFloat(Beq[i]));\r\n        }\r\n    }*/\r\n    let objectiveFunction = parseFunction(objectiveFunctionString,DIM);\r\n    if (objectiveFunction === -1){\r\n        return -1;\r\n    }\r\n    switch (selectedMethodString) {\r\n        case \"Multistart\":{\r\n            let startPoint = intitializePoint(parseStartPoint(params.startPoint));\r\n\r\n            if (startPoint===-2){\r\n                return -2;\r\n            }\r\n            if (!isStartPointCorrect(startPoint,lowerBound,upperBound)){\r\n                return -2;\r\n            }\r\n            let eps=parseFloat(params.eps);\r\n            let alpha=parseFloat(params.alpha);\r\n            let lambda=parseFloat(params.lambda);\r\n            let deltaVector=params.deltaVector.match(/[\\d.]+/g);\r\n            for (let i = 0; i < deltaVector.length; i++) {\r\n                deltaVector[i]=parseFloat(deltaVector[i]);\r\n            }\r\n            var returnedFromMethod = hookeJeeves(startPoint,objectiveFunction,eps,deltaVector,lambda,alpha);\r\n            break;\r\n        }\r\n        case \"SA\":{\r\n            let startPoint = intitializePoint(parseStartPoint(params.startPoint));\r\n            if (!isStartPointCorrect(startPoint,lowerBound,upperBound)){\r\n                return -2;\r\n            }\r\n            let maxIter=parseInt(params.maxIterations);\r\n            let startT=parseFloat(params.initialTemperature);\r\n            let endT=1;\r\n            var returnedFromMethod=simulatedAnnealing(startT,endT,maxIter,startPoint,objectiveFunction,lowerBound,upperBound);\r\n            break;\r\n        }\r\n        case \"Genetic\":{\r\n            let tMax=parseInt(params.maxIterations),m=parseInt(params.m),li=parseInt(params.li);\r\n            var returnedFromMethod=geneticBinary(tMax,m,objectiveFunction,lowerBound,upperBound,li);\r\n            break;\r\n        }\r\n        /*case \"Tunnel\":{\r\n            let startPoint,deltaVector,lambda,alpha,eps;\r\n            startPoint = intitializePoint(parseStartPoint(params.startPoint));\r\n            if (!isStartPointCorrect(startPoint,lowerBound,upperBound)){\r\n                return -2;\r\n            }\r\n            lambda=parseFloat(params.lambda);\r\n            alpha=parseFloat(params.alpha);\r\n            eps=parseFloat(params.eps);\r\n            let re=/[\\w.-]+/g;\r\n            deltaVector=params.deltaVector.match(re);\r\n            for (let i = 0; i < DIM; i++) {\r\n                deltaVector[i] = parseFloat(deltaVector[i]);\r\n                if (isNaN(deltaVector[i])){\r\n                    deltaVector[i]=Number.MIN_SAFE_INTEGER;\r\n                }\r\n            }\r\n            var returnedFromMethod = tunnel(startPoint,objectiveFunction,eps,deltaVector,lambda,alpha);\r\n            break;\r\n        }*/\r\n    }\r\n    let checkedPoints, functionIterations,xMin, fMin,functionValues;\r\n    checkedPoints = returnedFromMethod[0];\r\n    functionIterations = returnedFromMethod[1];\r\n    xMin = returnedFromMethod[2];\r\n    fMin = returnedFromMethod[3];\r\n    functionValues = returnedFromMethod[4];\r\n    let data=[checkedPoints,functionIterations,xMin,fMin,DIM,functionValues];\r\n    if (DIM <= 2){\r\n        let [X,Y,checkedPointsT,labelsList]=getValuesForPlot(objectiveFunction,lowerBound,upperBound,checkedPoints);\r\n        data.push(X,Y,checkedPointsT,labelsList);\r\n    }\r\n    return data;\r\n}\r\nexport default startOptimization;","function getPlot(X, Z, labelsList, checkedPoints, xMin,fMin,DIM) {\r\n    let scatterData = {\r\n        x: checkedPoints[0],\r\n        y: checkedPoints[1],\r\n        type: \"scatter\",\r\n        line: { color: \"red\" },\r\n        text: labelsList,\r\n        textposition: \"top center\",\r\n        mode: \"lines+markers+text\",\r\n        textfont: { color: \"white\" },\r\n        hoverinfo: \"x+y+z\",\r\n        name: \"Линия поиска\"\r\n    };\r\n    \r\n    switch (DIM) {\r\n        case 1:\r\n            var contourData = {\r\n                x: X[0],\r\n                y: Z,\r\n                type: \"scatter\",\r\n                line: { color: \"black\" },\r\n                hoverinfo: \"x+y\",\r\n                name: \"Целевая функция\"\r\n            };\r\n            var scatterMinData = {\r\n                x: [xMin.x1],\r\n                y: [fMin],\r\n                type: \"scatter\",\r\n                line: { color: \"Green\" },\r\n                marker: { symbol:\"diamond\",size:10 },\r\n                hoverinfo: \"x+y+z\",\r\n                name: \"x*\"\r\n            };\r\n            break;\r\n        case 2:\r\n            var contourData = {\r\n                x: X[0],\r\n                y: X[1],\r\n                z: Z,\r\n                type: \"contour\",\r\n                contours: { start: -900, end: 600, size: 20 },\r\n                name: \"Линии уровня\"\r\n            };\r\n            var scatterMinData = {\r\n                x: [xMin.x1],\r\n                y: [xMin.x2],\r\n                type: \"scatter\",\r\n                line: { color: \"Green\" },\r\n                marker: { symbol:\"diamond\",size:10 },\r\n                hoverinfo: \"x+y+z\",\r\n                name: \"x*\"\r\n            };\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n    let data = [scatterData,scatterMinData, contourData];\r\n\r\n    let layout = {\r\n        margin: { t: 10 },\r\n        hovermode: \"closest\",\r\n        showlegend: false\r\n    };\r\n    return [data,layout];\r\n}\r\n\r\nexport default getPlot;","import { useState } from \"react\";\nimport Options from \"./components/Options\"\nimport Constraints from \"./components/Constraints\"\nimport InputRow from \"./components/InputRow\";\nimport startOptimization from \"./modules/main\";\nimport getPlot from \"./modules/plot\"\nimport createPlotlyComponent from 'react-plotly.js/factory'\nimport Plotly from 'plotly.js-cartesian-dist'\nimport {BrowserView} from 'react-device-detect';\nimport \"./App.css\"\nvar parametersList=[];\nparametersList[\"objectiveFunction\"]=\"x1*sin(sqrt(abs(x1)))+x2*sin(sqrt(abs(x2)))\";\nparametersList[\"lowerBound\"]=\"-500 -500\";\nparametersList[\"upperBound\"]=\"500 500\";\nconst Plot = createPlotlyComponent(Plotly);\nconst rowsData=[\n  { id:\"objectiveFunction\", name:\"Целевая функция\",required:\"required\",pattern:\"[a-zA-Z0-9 +/.*^()-]+\" },\n  { id:\"lowerBound\", name:\"Нижняя граница\",required:\"required\",pattern:\"[pie\\\\d .,;\\\\[\\\\]-]+\" }, \n  { id:\"upperBound\", name:\"Верхняя граница\",required:\"required\",pattern:\"[pie\\\\d .,;\\\\[\\\\]-]+\" }\n];\n\nfunction App() {\n  var [plotState,setPlotState]=useState({\n    data:[],\n    layout:{}\n  });\n  var [results,setResults]=useState('');\n  var [method,setMethod]=useState(\"Genetic\");\n  const inputRowList=rowsData.map(row => \n    <InputRow key={row.id} id={row.id} name={row.name} pattern={row.pattern} sendData={sendData} required={row.required}/>);\n\n  function sendData(id,value) {\n    parametersList[id]=value;\n  }\n  function CheckParameters(){\n    try {\n      let startPoint=parametersList.startPoint;\n      let re=/[\\d.]+/g;\n      let r=startPoint.match(re);\n      if (r === null) {throw \"Пустая строка\";}\n      re=/^\\d+$|^\\d+\\.\\d+$/;\n      r.forEach(element => {\n        if (element.match(re) === null) { throw \"Слишком много точек\";}\n      });\n      let lowerBound=parametersList.lowerBound;\n      let upperBound=parametersList.upperBound;\n      re=/\\w+/g;\n      let rl=lowerBound.match(re);\n      let ru=upperBound.match(re);\n      if (rl === null || ru === null ) { throw \"Пустая строка\"; }\n      \n      \n    }\n    catch (error) {\n      return error;\n    }\n    return 0;\n  }\n  function onSubmit(e){\n    e.preventDefault();\n    /*var chk=CheckParameters();\n    if (chk !== 0) {\n      alert(chk); return;\n    }*/\n    var returnedFromMethod = startOptimization(method,parametersList);\n    if (returnedFromMethod === -1){\n      alert(\"Ошибка парсинга функции\");\n      return;\n    }\n    if (returnedFromMethod === -2){\n      alert(\"Некорректная точка старта\");\n      return;\n    }\n    let checkedPoints=returnedFromMethod[0],\n    functionIterations=returnedFromMethod[1],\n    xMin=returnedFromMethod[2],\n    fMin=returnedFromMethod[3],\n    DIM=returnedFromMethod[4];\n    let functionValues = returnedFromMethod[5];\n    if (DIM <= 2){\n      let X=returnedFromMethod[6],\n      Y=returnedFromMethod[7],\n      checkedPointsT=returnedFromMethod[8],\n      labelsList=returnedFromMethod[9];\n      let plotData=getPlot(X, Y, labelsList, checkedPointsT, xMin, fMin,DIM);\n      var newPlotState={\n        data:plotData[0],\n        layout:plotData[1]\n      };\n    }\n    else{\n      var newPlotState={\n        data:[],\n        layout:{}\n      };\n    }\n    //<textarea> filling\n    let s=\"\";\n    for (let i = 0; i < checkedPoints.length; i++) {\n      let stringVector=\"\";\n      for (const item of checkedPoints[i]) {\n        stringVector+=item.toFixed(4)+',';\n      }\n      stringVector=stringVector.slice(0,-2);//remove the last comma\n      s = s +i+ ': (' + stringVector+'). '+'f='+functionValues[i].toFixed(4)+'\\n';\n    }\n    let stringMinVector=\"\";\n    let j=1;\n    for (const i in xMin) {\n      stringMinVector+=xMin[i].toFixed(4)+',';\n      if (j === DIM){\n        break;\n      }\n      j++;\n    }\n    stringMinVector=stringMinVector.slice(0,-2);\n    let newResults=`${results}\\n${s}x*=(${stringMinVector}), f(x*)=${fMin.toFixed(4)}\\nВычислений целевой функции ${functionIterations}.\\n------`;\n    setPlotState(newPlotState);    \n    setResults(newResults);\n  }\n  \n  return (\n    <div className=\"App\">\n      <div className=\"main section\">\n        <div className=\"solver section\">\n          <label htmlFor=\"solver\">Выберите метод:</label>\n          <select id=\"solver\">\n            <option onClick={()=>setMethod(\"Multistart\")}>Метод мультистарта(Хука-Дживса)</option>\n            <option onClick={()=>setMethod(\"SA\")}>Метод имитации отжига</option>\n            <option onClick={()=>setMethod(\"Genetic\")}>Генетический алгоритм</option>\n          </select>\n        </div>\n        <div className=\"problem section\">\n          {inputRowList}\n        </div>\n        <Options method={method} sendData={sendData}/>\n        <form onSubmit={onSubmit}>\n        <div className=\"btn-submit section\">\n          <button id=\"btn-submit\">Старт</button>\n        </div>\n        </form>\n        <BrowserView>\n        <div className=\"plot section\">\n        <Plot data={plotState.data} layout={plotState.layout}\n            onInitialized={(figure) => setPlotState(figure)}\n            onUpdate={(figure) => setPlotState(figure)}/>\n        </div>\n        </BrowserView>\n        \n      </div>\n      \n      <div className=\"results section\">\n          <textarea className=\"tbox\" readOnly value={results}>\n          </textarea>\n      </div>\n    </div>  \n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}