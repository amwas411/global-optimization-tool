{"version":3,"sources":["components/InputRow.js","components/Options.js","modules/main.js","modules/plot.js","App.js","reportWebVitals.js","index.js"],"names":["InputRow","props","divId","id","className","htmlFor","name","type","required","pattern","autoComplete","onChange","e","sendData","target","checked","value","Options","DIM","hjOptionsList","map","data","saOptionsList","geneticOptionsList","swarmOptionsList","tabuOptionsList","saOptions","hjOptions","geneticOptions","swarmOptions","tabuOptions","method","math","create","all","EPS","CheckStringVector","stringVector","re","r","match","forEach","element","error","parseStartPoint","startPointString","lb","ub","startPoint","length","i","parseFloat","initializePoint","arr","x","x1","x2","x3","x4","x5","x6","x7","x8","x9","property","simulatedAnnealing","T","N","f","C","beta","getProbability","df","Math","exp","tossCoin","p","random","myRand","density","nx","norm","sqrt","PI","c","X","Array","Z","checkedPoints","Object","values","slice","functionValues","evaluate","dx","functionIterations","k","y","addition","key","assign","push","xMin","getValuesForPlot","objectiveFunction","lowerBound","upperBound","getNumbersBetween","range","step","abs","idx","Y","Xi","point","j","sort","a","b","coordsForContour","labelsList","checkedPointsT","createTree","objectiveFunctionString","node","parse","constants","Set","functions","symbols","traverse","isSymbolNode","add","isFunctionNode","has","setA","setB","difference","elem","delete","union","subtraction","multiplication","hookeJeeves","eps","deltaVector","lambda","alpha","yNext","xNext","loop1","loop2","filter","item","fMin","DoubleSidedMap","keys","this","index","findIndex","it","getRandomInt","min","max","ceil","floor","getMinimum","population","minValue","Number","MAX_SAFE_INTEGER","v","idxMin","getMaximum","maxValue","MIN_SAFE_INTEGER","idxMax","arrayContainsIn","mainArr","count","startOptimization","selectedMethodString","params","isNaN","t","replace","returned","size","symbols_sorted","from","symbols_new","dict","Map","set","transform","SymbolNode","get","console","log","toString","compile","parseFunction","start","Date","now","returnedFromMethod","methodTime","maxIter","parseInt","maxIterations","startT","initialTemperature","tMax","m","li","numbers","greys","grey","buildGrey","mapGrey","Creature","genotype","getValue","decode","g","gString","len","gS1","gString_","RegExp","parents","parentA","parentB","pA","pB","pA1","pA2","pB1","gsch1","gsch2","code","fenotype","chromosom","priznak","h","getByKey","genotypeDecoded","gamma","getByValue","M","P","xk","step2","probabilityInterval","masterLoop","coin","childCandidate","containsIn","crossover","sch1","sch2","mutate","geneticBinary","np","ni","omega","K","niVector","NImin","NImax","position","bestPosition","speed","bestPositionOfNeighbors","first","second","third","multiply","r1","r2","subtract","posValue","xArr","neighbors","minValueOfNeighbors","changePosition","particleSwarm","L","allowModification","mod","undefined","maxEdge","edge","delta","Rtr","Rstr","L_","Nmin","Mmin","TabuPoint","coordinate","Ir","If","mValue","Region","phi","getCentersOfTouchedSemiTabuRegions","tabuList","centers","lp","getMaxDistance","Dmax","getDirection","t_","d","sign","getStep","delta_","adaptiveSearch","sumOfDeltaF","fx","w","u","zer","zeros","uNum","uDen","divide","sigma","rp","newPoint","_data","fy","updateTabuList","tabuPoint","remove","updateVisitedRegionList","visitedRegionList","isRegionTouched","newRegion","points","Mr","Mf","Ir_","splice","sum","directionVector","fxNext","z","returnedfMin","tabuSearch","getPlot","scatterData","line","color","text","textposition","mode","textfont","hoverinfo","contourData","scatterMinData","marker","symbol","contours","end","margin","hovermode","showlegend","parametersList","Plot","createPlotlyComponent","Plotly","rowsData","methodFullName","App","useState","layout","plotState","setPlotState","results","setResults","setMethod","inputRowList","row","onClick","onSubmit","preventDefault","plotData","newPlotState","s","toFixed","stringMinVector","newResults","alert","onInitialized","figure","onUpdate","readOnly","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.ec7594f4.chunk.js","sourcesContent":["import \"../styles/InputRow.css\";\r\n\r\nfunction InputRow (props) {\r\n    function handleChange(e) {\r\n        if (props.id===\"mod\"){\r\n            props.sendData(props.id,e.target.checked);\r\n        }\r\n        else{\r\n            props.sendData(props.id,e.target.value);\r\n        }\r\n    }\r\n    const divId=props.id+\"-container\";\r\n    return (\r\n        <div id={divId}>\r\n            <label className=\"row-label\" htmlFor={props.id}>{props.name}</label>\r\n            <input className=\"row-input\" id={props.id} type={props.type} required={props.required} pattern={props.pattern} \r\n            autoComplete=\"off\" onChange={handleChange}/>\r\n        </div>\r\n    );\r\n}\r\nexport default InputRow;","import InputRow from \"../components/InputRow\";\r\nfunction Options(props) {\r\n    const saOptionsData = [\r\n        { id: \"startPoint\", name: \"Точка старта\", required: \"required\", pattern: \"[pie\\\\d .,;\\\\[\\\\]-]+\" },\r\n        { id: \"maxIterations\", name: \"Количество итераций\", required: \"required\", pattern: \"[1-9]\\\\d*\" },\r\n        { id: \"initialTemperature\", name: \"Начальная температура(>0)\", required: \"required\", pattern: \"[\\\\d .]+\" },\r\n        { id: \"c\", name: \"Параметр распределения Больцмана (>0)\", required: \"required\", pattern: \"[\\\\d .]+\" },\r\n        { id: \"beta\", name: \"Параметр уменьшения температуры [0.8;0.99]\", required: \"required\", pattern: \"[\\\\d .]+\" }\r\n    ];\r\n    const hjOptionsData = [\r\n        { id: \"startPoint\", name: \"Точка старта\", required: \"required\", pattern: \"[pie\\\\d .,;\\\\[\\\\]-]+\" },\r\n        { id: \"deltaVector\", name: \"Вектор длин шагов\", required: \"required\", pattern: \"[pie\\\\d .,;\\\\[\\\\]-]+\" },\r\n        { id: \"lambda\", name: \"Лямбда (Множитель шага >0)\", required: \"required\", pattern: \"[\\\\d. ]+\" },\r\n        { id: \"alpha\", name: \"Альфа (Коэф.уменьшения шага >1)\", required: \"required\", pattern: \"[\\\\d. ]+\" },\r\n        { id: \"eps\", name: \"Эпсилон(для остановки алгоритма >0)\", required: \"required\", pattern: \"[\\\\d. ]+\" }\r\n    ];\r\n    const geneticOptionsData = [\r\n        { id: \"maxIterations\", name: \"Количество итераций\",type:\"text\", required: \"required\", pattern: \"[1-9]\\\\d*\" },\r\n        { id: \"m\", name: \"Объём популяции\",type:\"text\", required: \"required\", pattern: \"[1-9]\\\\d*\" },\r\n        { id: \"li\", name: \"Длина кодирования гена(<15)\",type:\"text\", required: \"required\", pattern: \"[1-9]\\\\d*\" }\r\n    ];\r\n    const swarmOptionsData = [\r\n        { id: \"maxIterations\", name: \"Количество итераций\",type:\"text\", required: \"required\", pattern: \"[1-9]\\\\d*\" },\r\n        { id: \"np\", name: \"Количество частиц в стае\",type:\"text\", required: \"required\", pattern: \"[1-9]\\\\d*\" },\r\n        { id: \"ni\", name: \"Мин. и макс. число соседей\",type:\"text\", required: \"required\", pattern: \"[\\\\d ,;\\\\[\\\\]]+\" },\r\n        { id: \"omega\", name: \"Весовой коэф.(0.01;0.7)\",type:\"text\", required: \"required\", pattern: \"[\\\\d. ]+\" },\r\n        { id: \"alpha\", name: \"Альфа(для вычисления скорости)\",type:\"text\", required: \"required\", pattern: \"[\\\\d. ]+\" },\r\n        { id: \"beta\", name: \"Бета(для вычисления скорости)\",type:\"text\", required: \"required\", pattern: \"[\\\\d. ]+\" }\r\n    ];\r\n    const tabuOptionsData = [\r\n        { id: \"M\", name: \"Количество попыток иссл. поиска M\",type:\"text\", required: \"required\", pattern: \"[1-9]\\\\d*\" },\r\n        { id: \"N\", name: \"Количество попыток иссл.-пер. поиска N\",type:\"text\", required: \"required\", pattern: \"[1-9]\\\\d*\" },\r\n        { id: \"L\", name: \"Количество записей в табу-листе L\", type:\"text\", required: \"required\", pattern: \"[1-9]\\\\d*\" },\r\n        { id: \"mod\", name: \"С методом ИО\", type:\"checkbox\", required: \"\", pattern: \"\" }\r\n    ];\r\n\r\n    const hjOptionsList = hjOptionsData.map(data =>\r\n        <InputRow key={data.id} id={data.id} name={data.name} pattern={data.pattern} type={data.type} required={data.required} sendData={props.sendData} />);\r\n    const saOptionsList = saOptionsData.map(data =>\r\n        <InputRow key={data.id} id={data.id} name={data.name} pattern={data.pattern} type={data.type} required={data.required} sendData={props.sendData} />);\r\n    const geneticOptionsList = geneticOptionsData.map(data =>\r\n        <InputRow key={data.id} id={data.id} name={data.name} pattern={data.pattern} type={data.type} required={data.required} sendData={props.sendData} />);\r\n    const swarmOptionsList = swarmOptionsData.map(data =>\r\n        <InputRow key={data.id} id={data.id} name={data.name} pattern={data.pattern} type={data.type} required={data.required} sendData={props.sendData} />);\r\n    const tabuOptionsList = tabuOptionsData.map(data =>\r\n        <InputRow key={data.id} id={data.id} name={data.name} pattern={data.pattern} type={data.type} required={data.required} sendData={props.sendData} />);\r\n    const saOptions = (\r\n        <div className=\"options section\">\r\n            {saOptionsList}\r\n        </div>\r\n    );\r\n    const hjOptions = (\r\n        <div className=\"options section\">\r\n            {hjOptionsList}\r\n        </div>\r\n    );\r\n    const geneticOptions = (\r\n        <div className=\"options section\">\r\n            {geneticOptionsList}\r\n        </div>\r\n    );\r\n    const swarmOptions = (\r\n        <div className=\"options section\">\r\n            {swarmOptionsList}\r\n        </div>\r\n    );\r\n    const tabuOptions = (\r\n        <div className=\"options section\">\r\n            {tabuOptionsList}\r\n        </div>\r\n    );\r\n    switch (props.method) {\r\n        case \"SA\":\r\n            return saOptions;\r\n        case \"HJ\":\r\n            return hjOptions;\r\n        case \"Genetic\":\r\n            return geneticOptions;\r\n        case \"Swarm\":\r\n            return swarmOptions;\r\n        case \"Tabu\":\r\n            return tabuOptions;\r\n        default:\r\n            break;\r\n    }\r\n}\r\nexport default Options;","import { create, all } from \"mathjs\";\r\nconst math = create({\r\n    all\r\n});\r\nvar DIM;\r\nconst EPS = 1e-8;\r\nfunction CheckStringVector(stringVector) {\r\n    try {\r\n      let re = /[\\w.]+/g;\r\n      let r = stringVector.match(re);\r\n      if (r === null) { throw \"Пустая строка\"; }\r\n      re = /^\\d+$|^\\d+\\.\\d+$/;\r\n      r.forEach(element => {\r\n        if (element.match(re) === null) { throw \"Слишком много точек\"; }\r\n      });\r\n    }\r\n    catch (error) {\r\n      return error;\r\n    }\r\n    return 0;\r\n  }\r\nfunction parseStartPoint(startPointString,lb,ub) {\r\n    let re = /[\\w.-]+/g;\r\n    let startPoint = startPointString.match(re);\r\n    if (startPoint.length !== DIM) {\r\n        return -2;\r\n    }\r\n    for (let i = 0; i < DIM; i++) {\r\n        startPoint[i] = parseFloat(startPoint[i]);\r\n        if (startPoint[i] < lb[i]){\r\n            startPoint[i]=lb[i];\r\n        }\r\n        else {\r\n            if (startPoint[i] > ub[i]){\r\n            startPoint[i]=ub[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    return startPoint;\r\n}\r\nfunction initializePoint(arr) {\r\n    let x = { x1: 0, x2: 0, x3: 0, x4: 0, x5: 0, x6: 0, x7: 0, x8: 0, x9: 0 };\r\n    let i = 0;\r\n    for (const property in x) {\r\n        x[property] = arr[i++];\r\n        if (i === DIM) {\r\n            break;\r\n        }\r\n    }\r\n    return x;\r\n}\r\n\r\n\r\nfunction simulatedAnnealing(T, N, x, f, C, beta, lb, ub) {\r\n    function getProbability(df, C, T) { return Math.exp(-df / C / T); }\r\n    function tossCoin(p) { return Math.random() < p; }\r\n\r\n    function myRand(T) {\r\n        function density(x, T) {\r\n            let nx = math.norm(x);\r\n            return Math.exp(-(nx ** 2 / 2 / T)) / (Math.sqrt(2 * Math.PI * T)) ** DIM;\r\n        }\r\n        let a = -10, b = 10;\r\n        let N = 1000;\r\n        let c = density(0, T);\r\n        let X = new Array(2), Z = new Array(2);\r\n        for (let i = 0; i < N; i++) {\r\n            X[0] = Math.random();\r\n            X[1] = Math.random();\r\n            Z[0] = a + X[0] * (b - a);\r\n            Z[1] = X[1] * c;\r\n            if (Z[1] < density(Z[0])) {\r\n                return Z[0];\r\n            }\r\n        }\r\n        return Z[0];\r\n    }\r\n    x = initializePoint(x);\r\n    let checkedPoints = [Object.values(x).slice(0, DIM)];\r\n    let functionValues = [f.evaluate(x)];\r\n    let dx = new Array(DIM);\r\n    let functionIterations = 0;\r\n    for (let k = 0; k < N - 1; k++) {\r\n        for (let i = 0; i < DIM; i++) {\r\n            dx[i] = myRand(T);\r\n        }\r\n        let dx_ = initializePoint(dx);\r\n        let y = addition(x, dx_);\r\n        let i = 0;\r\n        for (const key in y) {\r\n            if (y[key] > ub[i]) {\r\n                y[key] = ub[i];\r\n            }\r\n            else {\r\n                if (y[key] < lb[i]) {\r\n                    y[key] = lb[i];\r\n                }\r\n            }\r\n        }\r\n        let df = f.evaluate(y) - f.evaluate(x);\r\n        functionIterations += 2;\r\n        if (df < 0) {\r\n            x = Object.assign({}, y);\r\n            checkedPoints.push(Object.values(x).slice(0, DIM));\r\n            functionValues.push(f.evaluate(x));\r\n        }\r\n        else {\r\n            let p = getProbability(df, C, T);\r\n            if (tossCoin(p) === true) {\r\n                x = Object.assign({}, y);\r\n                checkedPoints.push(Object.values(x).slice(0, DIM));\r\n                functionValues.push(f.evaluate(x));\r\n            }\r\n        }\r\n        T *= beta;\r\n    }\r\n    let xMin = Object.assign({}, x);\r\n    let fMin = f.evaluate(xMin);\r\n    return [checkedPoints, functionIterations, xMin, fMin, functionValues];\r\n}\r\n\r\nfunction coordsForContour(lowerBound, upperBound, objectiveFunction, checkedPoints) {\r\n    function getNumbersBetween(lowerBound, upperBound, N) {\r\n        var range = new Array(N);\r\n        var step = Math.abs((upperBound - lowerBound)) / N;\r\n        var idx = 0;\r\n        for (let i = lowerBound; i < upperBound - EPS; i += step) {\r\n            range[idx] = i;\r\n            idx++;\r\n        }\r\n        return range;\r\n    }\r\n    var N = 100; //quantity\r\n    var X = [];\r\n    var Y;\r\n    for (let i = 0; i < DIM; i++) {\r\n        let Xi = getNumbersBetween(lowerBound[i], upperBound[i], N);\r\n        X.push(Xi);\r\n    }\r\n\r\n    for (const point of checkedPoints) {\r\n        for (let j = 0; j < DIM; j++) {\r\n            X[j].push(point[j]);\r\n        }\r\n    }\r\n    for (let i = 0; i < DIM; i++) {\r\n        X[i].sort(function (a, b) {\r\n            return a - b;\r\n        });\r\n    }\r\n    N += checkedPoints.length;\r\n    if (DIM === 2) {\r\n        Y = new Array(N);\r\n        for (let i = 0; i < N; i++) {\r\n            Y[i] = new Array(N);\r\n        }\r\n        for (let i = 0; i < N; i++) {\r\n            for (let j = 0; j < N; j++) {\r\n                let x = { x1: X[0][i], x2: X[1][j] };\r\n                Y[j][i] = objectiveFunction.evaluate(x);//rows - Yaxis, cols - Xaxis in plotly contour\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        Y = [];\r\n        for (let i = 0; i < N; i++) {\r\n            let x = { x1: X[0][i] };\r\n            Y.push(objectiveFunction.evaluate(x));//rows - Yaxis, cols - Xaxis in plotly contour\r\n        }\r\n    }\r\n    return [X, Y];\r\n}\r\n\r\nfunction getValuesForPlot(objectiveFunction, lowerBound, upperBound, checkedPoints) {\r\n    let [X, Y] = coordsForContour(lowerBound, upperBound, objectiveFunction, checkedPoints);\r\n    let labelsList = [];\r\n    for (let i = 0; i <= checkedPoints.length; i++) {\r\n        labelsList.push(i);\r\n    }\r\n    //checkedPoints transposed\r\n    var checkedPointsT = [];\r\n    for (let i = 0; i < DIM; i++) {\r\n        checkedPointsT[i] = new Array(checkedPoints.length);\r\n    }\r\n\r\n    for (let i = 0; i < checkedPoints.length; i++) {\r\n        let point = checkedPoints[i];\r\n        for (let j = 0; j < DIM; j++) {\r\n            checkedPointsT[j][i] = point[j];\r\n        }\r\n    }\r\n    //compute function values on the search line\r\n    if (DIM === 1) {\r\n        checkedPointsT[1] = new Array(checkedPointsT[0].length);\r\n        for (let i = 0; i < checkedPointsT[0].length; i++) {\r\n            checkedPointsT[1][i] = objectiveFunction.evaluate({ x1: checkedPointsT[0][i] });\r\n        }\r\n    }\r\n    return [X, Y, checkedPointsT, labelsList];\r\n}\r\n//difference = set - subset\r\nfunction difference(setA, setB) {\r\n    let difference = new Set(setA);\r\n    for (let elem of setB) {\r\n        if (difference.has(elem)) {\r\n            difference.delete(elem);\r\n        }\r\n    }\r\n    return difference;\r\n}\r\nfunction union(setA, setB) {\r\n    let union = new Set(setA)\r\n    for (let elem of setB) {\r\n        union.add(elem)\r\n    }\r\n    return union\r\n}\r\n\r\nfunction createTree(objectiveFunctionString) {\r\n    var node = math.parse(objectiveFunctionString);\r\n    var constants = new Set(['pi', 'e', 'E', 'i', 'PI']);\r\n    var functions = new Set(['sin', 'cos', 'tan', 'cot', 'exp', 'abs', 'sqrt', 'sign', 'log',\r\n        'log10', 'log2', 'nthRoot', 'acos', 'acot', 'asin', 'atan', 'sec', 'norm']);\r\n    var symbols = new Set();\r\n    node.traverse(function (node) {\r\n        if (node.isSymbolNode) {\r\n            symbols.add(node.name);\r\n        }\r\n        else if (node.isFunctionNode && functions.has(node.name)) {\r\n            functions.add(node.name);\r\n        }\r\n    });\r\n    symbols = difference(symbols, union(constants, functions));\r\n    return [node, symbols];\r\n}\r\n\r\nfunction parseFunction(objectiveFunctionString, DIM) {\r\n    let c = new Set(['pi', 'e', 'E', 'i', 'PI', 'sin', 'cos', 'tan', 'cot', 'exp', 'abs', 'sqrt', 'sign', 'log',\r\n        'log10', 'log2', 'nthRoot', 'acos', 'acot', 'asin', 'atan', 'sec', 'norm']);\r\n    try {\r\n        //mapping \"(\" -> \"*(\"\r\n        let re = /[\\w.]+(?=\\()/g;\r\n        let r = objectiveFunctionString.match(re);\r\n        if (r !== null) {\r\n            r = r.filter(item => !c.has(item));\r\n            r.forEach(t => {\r\n                objectiveFunctionString = objectiveFunctionString.replace(t, t + '*');\r\n            });\r\n        }\r\n        let returned = createTree(objectiveFunctionString);\r\n        let node = returned[0];\r\n        let symbols = returned[1];\r\n        if (symbols.size !== DIM) { throw \"Несоответствие размерностей целевой функции и стартовой точки.\"; }\r\n        //renaming variables to the hardcoded names\r\n        let symbols_sorted = Array.from(symbols).sort();\r\n        let symbols_new = ['x1', 'x2', 'x3', 'x4', 'x5', 'x6', 'x7', 'x8', 'x9'];\r\n        if (symbols_sorted !== symbols_new) {\r\n            let dict = new Map();\r\n            for (let i = 0; i < symbols_sorted.length; i++) {\r\n                dict.set(symbols_sorted[i], symbols_new[i]);\r\n            }\r\n            node = node.transform(function (node) {\r\n                if (node.isSymbolNode && symbols.has(node.name)) {\r\n                    return new math.SymbolNode(dict.get(node.name));\r\n                }\r\n                else {\r\n                    return node;\r\n                }\r\n            });\r\n        }\r\n        console.log(node.toString());\r\n        /*node.traverse(function (node) {\r\n            var chck = node.isFunctionNode;\r\n            console.log(node.type, node.op, node.value,node.name,chck);\r\n        });*/\r\n        let compiled_node = node.compile();\r\n        return compiled_node;\r\n    }\r\n    catch (error) {\r\n        return -1;\r\n    }\r\n}\r\n/*function isStartPointCorrect(startPoint, lb, ub) {\r\n    for (let i = 0; i < DIM; i++) {\r\n        if (startPoint[i] > ub[i] || startPoint[i] < lb[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}*/\r\n\r\nfunction subtraction(a, b) {\r\n    let r = Object.create(a);\r\n    for (const property in a) {\r\n        r[property] = a[property] - b[property];\r\n    }\r\n    return r;\r\n}\r\nfunction addition(a, b) {\r\n    let r = Object.create(a);\r\n    for (const property in a) {\r\n        r[property] = a[property] + b[property];\r\n    }\r\n    return r;\r\n}\r\nfunction multiplication(a, b) {\r\n    let r = Object.create(b);\r\n    if (typeof a === \"number\") {\r\n        for (const property in b) {\r\n            r[property] = a * b[property];\r\n        }\r\n    }\r\n    else {\r\n        for (const property in a) {\r\n            r[property] = a[property] * b[property];\r\n        }\r\n    }\r\n    return r;\r\n}\r\nfunction division(a, b) {\r\n    let r = Object.create(a);\r\n    for (const property in a) {\r\n        r[property] = a[property] / b[property];\r\n    }\r\n    return r;\r\n}\r\n\r\nfunction hookeJeeves(x, f, eps, deltaVector, lambda, alpha, lb, ub) {\r\n    x = initializePoint(x);\r\n    let y = x, i = 1, yNext, xNext;\r\n    let functionIterations = 0;\r\n    let checkedPoints = [(Object.values(y).slice(0, DIM))];\r\n    let functionValues = [f.evaluate(y)];\r\n    yNext = Object.assign({}, y);\r\n    loop1: for (; ;) {\r\n        loop2: for (const key in y) {\r\n            //step 2a\r\n            yNext[key] += deltaVector[i - 1];\r\n            if (yNext[key] > ub[i - 1]) {\r\n                yNext[key] = ub[i - 1];\r\n            }\r\n            functionIterations += 2;\r\n            if (f.evaluate(yNext) < f.evaluate(y) - EPS) {\r\n                y = Object.assign({}, yNext);\r\n                checkedPoints.push((Object.values(y).slice(0, DIM)));\r\n                functionValues.push(f.evaluate(y));\r\n            }\r\n            else {//step 2b\r\n                yNext[key] = yNext[key] - 2 * deltaVector[i - 1];//cancel addition on the step2a and then subtraction\r\n                if (yNext[key] < lb[i - 1]) {\r\n                    yNext[key] = lb[i - 1];\r\n                }\r\n                functionIterations += 2;\r\n                if (f.evaluate(yNext) < f.evaluate(y) - EPS) {\r\n                    y = Object.assign({}, yNext);\r\n                    checkedPoints.push((Object.values(y).slice(0, DIM)));\r\n                    functionValues.push(f.evaluate(y));\r\n                }\r\n                else {\r\n                    yNext = Object.assign({}, y);\r\n                }\r\n            }\r\n            //step 3a\r\n            if (i < DIM) {\r\n                i++;\r\n                continue loop2;\r\n            }\r\n            //step 3b\r\n            if (i === DIM) {\r\n                //step 4\r\n                functionIterations += 2;\r\n                if (f.evaluate(yNext) < f.evaluate(x) - EPS) {\r\n                    xNext = Object.assign({}, yNext);\r\n                    y = addition(xNext, multiplication(lambda, (subtraction(xNext, x))));\r\n                    for (const key in y) {\r\n                        if (y[key] > ub[i - 1]) {\r\n                            y[key] = ub[i - 1];\r\n                        }\r\n                        else {\r\n                            if (y[key] < lb[i - 1]) {\r\n                                y[key] = lb[i - 1];\r\n                            }\r\n                        }\r\n                    }\r\n                    x = Object.assign({}, xNext);\r\n                    yNext = Object.assign({}, y);\r\n                    checkedPoints.push((Object.values(yNext).slice(0, DIM)));\r\n                    functionValues.push(f.evaluate(yNext));\r\n                    i = 1;\r\n                    break loop2;\r\n                }\r\n                else {//step 5a\r\n                    let r = deltaVector.filter(item => item < eps + EPS);\r\n                    if (r.length === deltaVector.length) {\r\n                        var xMin = Object.assign({}, x);\r\n                        functionIterations++;\r\n                        var fMin = f.evaluate(x);\r\n                        break loop1;\r\n                    }\r\n                    else {//step 5b\r\n                        for (let i = 0; i < deltaVector.length; i++) {\r\n                            if (deltaVector[i] > eps + EPS) {\r\n                                deltaVector[i] /= alpha;\r\n                            }\r\n                        }\r\n                        y = Object.assign({}, x);\r\n                        yNext = Object.assign({}, x);\r\n                        //x = Object.assign({},xNext);\r\n                        i = 1;\r\n                        break loop2;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return [checkedPoints, functionIterations, xMin, fMin, functionValues];\r\n}\r\n\r\n\r\nclass DoubleSidedMap {\r\n    constructor(keys, values) {\r\n        this.keys = keys;\r\n        this.values = values;\r\n    }\r\n    getByKey(key) {\r\n        const index = this.keys.findIndex(it => it === key);\r\n        return this.values[index];\r\n    }\r\n    getByValue(value) {\r\n        const index = this.values.findIndex(it => it === value);\r\n        return this.keys[index];\r\n    }\r\n}\r\nfunction getRandomInt(min, max) {\r\n    min = Math.ceil(min);\r\n    max = Math.floor(max);\r\n    return Math.floor(Math.random() * (max - min) + min);\r\n}\r\n\r\nfunction getMinimum(population) {\r\n    let minValue = Number.MAX_SAFE_INTEGER;\r\n    for (let i = 0; i < population.length; i++) {\r\n        let v = population[i].value;\r\n        if (v < minValue - EPS) {\r\n            var idxMin = i;\r\n            minValue = v;\r\n        }\r\n    }\r\n    return idxMin;\r\n}\r\nfunction getMaximum(population) {\r\n    let maxValue = Number.MIN_SAFE_INTEGER;\r\n    for (let i = 0; i < population.length; i++) {\r\n        let v = population[i].value;\r\n        if (v - EPS > maxValue) {\r\n            var idxMax = i;\r\n            maxValue = v;\r\n        }\r\n    }\r\n    return idxMax;\r\n}\r\nfunction arrayContainsIn(mainArr, arr) {\r\n    for (const it of mainArr) {\r\n        let count = 0;\r\n        for (let i = 0; i < it.length; i++) {\r\n            if (Math.abs(it[i] - arr[i]) < EPS) {\r\n                count++;\r\n            }\r\n        }\r\n        if (count === arr.length) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction geneticBinary(tMax, m, f, lb, ub, li) {\r\n    function buildGrey(li) {\r\n        let grey = new Array(2 ** li);\r\n        grey[0] = \"0\";\r\n        grey[1] = \"1\";\r\n        let p = 2;\r\n        for (let i = 2; i <= li; i++) {\r\n            let t = p - 1;\r\n            p *= 2;\r\n            for (let k = Math.floor(p / 2); k < p; k++) {\r\n                grey[k] = grey[t];\r\n                grey[t] = \"0\" + grey[t];\r\n                grey[k] = \"1\" + grey[k];\r\n                t--;\r\n            }\r\n        }\r\n        return grey;\r\n    }\r\n    let numbers = new Array(2 ** li);\r\n    for (let i = 0; i < 2 ** li; i++) {\r\n        numbers[i] = i;\r\n    }\r\n    let greys = buildGrey(li);\r\n    let mapGrey = new DoubleSidedMap(numbers, greys);\r\n    let k = 2 ** li - 1;\r\n    class Creature {\r\n        constructor(genotype) {\r\n            this.genotype = genotype;\r\n            this.value = getValue(decode(genotype));\r\n        }\r\n        static crossover(parents) { //одноточечное скрещивание\r\n            let parentA = parents[0].genotype, parentB = parents[1].genotype;\r\n            //parentA=[\"1110\",\"1000\",\"1010\"], B=[\"0001\",\"0100\",\"0101\"] 1..DIM\r\n            //\"111010001010\"->\"111.010001010\"->\"111101000101\"->\"1111,0100,0101\"\r\n            //\"000101000101\"->\"000.101000101\"->\"000010001010\"->\"0000,1000,1010\"\r\n            let pA = \"\", pB = \"\";\r\n            for (let i = 0; i < DIM; i++) {\r\n                pA += parentA[i];\r\n                pB += parentB[i];\r\n            }\r\n            let len = pA.length;\r\n            let idx = getRandomInt(1, len);\r\n            let pA1 = pA.slice(0, idx), pA2 = pA.slice(idx, len);\r\n            let pB1 = pB.slice(0, idx), pB2 = pB.slice(idx, len);\r\n            let gsch1 = pA1 + pB2;\r\n            let gsch2 = pB1 + pA2;\r\n            let re = new RegExp(`\\\\d{${li}}`, `g`);\r\n            gsch1 = gsch1.match(re);\r\n            gsch2 = gsch2.match(re);\r\n            let sch1 = new Creature(gsch1), sch2 = new Creature(gsch2);\r\n            return [sch1, sch2];\r\n        }\r\n        mutate() { //инверсия\r\n            let g = this.genotype;\r\n            let gString = \"\";\r\n            for (let i = 0; i < DIM; i++) {\r\n                gString += g[i];\r\n            }\r\n            let len = gString.length;\r\n            let idx = getRandomInt(1, len);\r\n            let gS1 = gString.slice(0, idx), gS2 = gString.slice(idx, len);\r\n            let gString_ = gS2 + gS1;\r\n            let re = new RegExp(`\\\\d{${li}}`, `g`);\r\n            this.genotype = gString_.match(re);\r\n            this.value = getValue(decode(this.genotype));\r\n        }\r\n        containsIn(arr) {\r\n            for (const i of arr) {\r\n                if (i.genotype === this.genotype) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n    function code(fenotype) {\r\n        let genotype = new Array(DIM);\r\n        //fenotype=[p1,p2,..,pn] -> genotype=[\"1010\",\"1111\",...,\"1100\"]\r\n        //priznak=pi\r\n        //chromosom=\"abcd\"\r\n        for (let i = 0; i < DIM; i++) {\r\n            let chromosom, beta;\r\n            let priznak = fenotype[i];\r\n            if (Math.abs(priznak - lb[i]) < EPS) {\r\n                beta = 0;\r\n            }\r\n            else {\r\n                let h = (ub[i] - lb[i]) / (k - 1);\r\n                beta = Math.floor((priznak - lb[i]) / h) + 1;//номер признака\r\n                chromosom = mapGrey.getByKey(beta);\r\n            }\r\n            genotype[i] = chromosom;\r\n        }\r\n        return genotype;\r\n    }\r\n    function decode(genotype) {\r\n        let genotypeDecoded = new Array(DIM);\r\n        for (let i = 0; i < DIM; i++) {\r\n            let priznak;\r\n            let gamma = mapGrey.getByValue(genotype[i]);\r\n            if (gamma === 0) {\r\n                priznak = lb[i];\r\n            }\r\n            else {\r\n                if (gamma === k) {\r\n                    priznak = ub[i];\r\n                }\r\n                else {\r\n                    let h = (ub[i] - lb[i]) / (k - 1);\r\n                    priznak = ((lb[i] + (gamma - 1) * h) + (lb[i] + gamma * h)) / 2;\r\n                }\r\n            }\r\n            genotypeDecoded[i] = priznak;\r\n        }\r\n        return genotypeDecoded;\r\n    }\r\n    function getValue(g) {\r\n        let x = initializePoint(g);\r\n        let fx = f.evaluate(x);\r\n        return fx;\r\n    }\r\n    let t = 0, M = 1;\r\n    //шаг 1 начальная популяция\r\n    let P = new Array(m);\r\n    let population = new Array(m);\r\n    //let sumOfValues=0;\r\n    let functionIterations = m, checkedPoints = [], functionValues = [];\r\n    for (let i = 0; i < m; i++) {\r\n        P[i] = new Array(DIM);\r\n        for (let j = 0; j < DIM; j++) {\r\n            P[i][j] = (ub[j] - lb[j]) * Math.random() + lb[j];\r\n        }\r\n        let fenotype = P[i];\r\n        let genotype = code(fenotype);\r\n        let c = new Creature(genotype);\r\n        //sumOfValues+=c.value;\r\n        population[i] = c;\r\n    }\r\n    let idxMin = getMinimum(population);\r\n    let xk = decode(population[idxMin].genotype);\r\n    let xMin = initializePoint(xk);\r\n    let fMin = f.evaluate(xMin);\r\n    if (!arrayContainsIn(checkedPoints, xk)) {\r\n        checkedPoints.push(xk);\r\n        functionValues.push(fMin);\r\n    }\r\n    /*let probabilities=new Array(m+1);\r\n    probabilities[0]=0;\r\n    for (let i = 1; i < m+1; i++) {\r\n        probabilities[i]=probabilities[i-1]+population[i-1].value/sumOfValues;\r\n    }*/\r\n    //шаг 2. селекция\r\n    step2: for (; ;) {\r\n        let probabilityInterval = new Array(m + 1);\r\n        let parents = [];\r\n        probabilityInterval[0] = 0;\r\n        for (let i = 1; i < m + 1; i++) {\r\n            probabilityInterval[i] = probabilityInterval[i - 1] + 1 / m; //панмиксия\r\n        }\r\n        masterLoop: for (; ;) {\r\n            let coin = Math.random();\r\n            slaveLoop: for (let i = 1; i < m + 1; i++) {\r\n                if (probabilityInterval[i - 1] < coin && coin < probabilityInterval[i]) {\r\n                    let childCandidate = population[i - 1];\r\n                    if (!childCandidate.containsIn(parents)) {\r\n                        parents.push(childCandidate);\r\n                        if (parents.length === 2) {\r\n                            break masterLoop;\r\n                        }\r\n                        else {\r\n                            continue masterLoop;\r\n                        }\r\n                    }\r\n                    else {\r\n                        continue masterLoop;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        //шаг 3 скрещивание\r\n        let [sch1, sch2] = Creature.crossover(parents);\r\n        //шаг 4 мутация\r\n        sch1.mutate();\r\n        sch2.mutate();\r\n        functionIterations += 2;\r\n        let idxMax = getMaximum(population);\r\n        let coin = Math.random();\r\n        if (coin - EPS > 0.5) {\r\n            population[idxMax] = sch1;\r\n        }\r\n        else {\r\n            population[idxMax] = sch2;\r\n        }\r\n        let idxMin = getMinimum(population);\r\n        let xk = decode(population[idxMin].genotype);\r\n        xMin = initializePoint(xk);\r\n        fMin = f.evaluate(xMin);\r\n        if (!arrayContainsIn(checkedPoints, xk)) {\r\n            checkedPoints.push(xk);\r\n            functionValues.push(fMin);\r\n        }\r\n        if (M < m) {\r\n            M++;\r\n            continue step2;\r\n        }\r\n        if (M === m) {\r\n            t++;\r\n        }\r\n        if (t === tMax) {\r\n            let idxMin = getMinimum(population);\r\n            let xk = decode(population[idxMin].genotype);\r\n            xMin = initializePoint(xk);\r\n            fMin = f.evaluate(xMin);\r\n            if (!arrayContainsIn(checkedPoints, xk)) {\r\n                checkedPoints.push(xk);\r\n                functionValues.push(fMin);\r\n            }\r\n            break step2;\r\n        }\r\n        else {\r\n            M = 1;\r\n            continue step2;\r\n        }\r\n    }\r\n    return [checkedPoints, functionIterations, xMin, fMin, functionValues];\r\n}\r\nfunction particleSwarm(f, lb, ub, K, np, niVector, omega, alpha, beta) {\r\n    let NImin = niVector[0], NImax = niVector[1];\r\n    class Creature {\r\n        constructor(position) {\r\n            this.position = position;\r\n            this.bestPosition = position;\r\n            this.value = f.evaluate(initializePoint(position));\r\n            this.speed = new Array(DIM);\r\n            for (let i = 0; i < DIM; i++) {\r\n                this.speed[i] = 0;\r\n            }\r\n        }\r\n        changePosition(bestPositionOfNeighbors) {\r\n            let first, second, third;\r\n            first = math.multiply(omega, this.speed);\r\n            masterLoop: for (let i = 0; i < 20; i++) {\r\n                let r1 = Math.random(), r2 = Math.random();\r\n                second = math.multiply((alpha * r1), math.subtract(this.bestPosition, this.position));\r\n                third = math.multiply((omega * beta * r2), math.subtract(bestPositionOfNeighbors, this.position));\r\n                this.speed = math.add(first, second, third);\r\n                this.position = math.add(this.position, this.speed);\r\n                slaveLoop: for (let i = 0; i < DIM; i++) {\r\n                    if (this.position[i] - EPS > ub[i] || this.position[i] < lb[i] - EPS) {\r\n                        continue masterLoop;\r\n                    }\r\n                    else {\r\n                        break masterLoop;\r\n                    }\r\n                }\r\n            }\r\n            for (let i = 0; i < DIM; i++) {\r\n                if (this.position[i] - EPS > ub[i]) {\r\n                    this.position[i] = ub[i];\r\n                }\r\n                else {\r\n                    if (this.position[i] < lb[i] - EPS) {\r\n                        this.position[i] = lb[i];\r\n                    }\r\n                }\r\n            }\r\n            let posValue = f.evaluate(initializePoint(this.position));\r\n            this.value = posValue;\r\n            if (posValue < f.evaluate(initializePoint(this.bestPosition)) - EPS) {\r\n                this.bestPosition = this.position;\r\n            }\r\n        }\r\n    }\r\n    //step 2\r\n    let P = new Array(np);\r\n    let population = new Array(np);\r\n    let functionIterations = 0, checkedPoints = [], functionValues = [];\r\n    for (let i = 0; i < np; i++) {\r\n        P[i] = new Array(DIM);\r\n        for (let j = 0; j < DIM; j++) {\r\n            P[i][j] = (ub[j] - lb[j]) * Math.random() + lb[j];\r\n        }\r\n        let creaturePosition = P[i];\r\n        let c = new Creature(creaturePosition);\r\n        population[i] = c;\r\n    }\r\n    let idxMin = getMinimum(population);\r\n    let xArr = population[idxMin].position;\r\n    let xMin = initializePoint(xArr);\r\n    let fMin = f.evaluate(xMin);\r\n    if (!arrayContainsIn(checkedPoints, xArr)) {\r\n        checkedPoints.push(xArr);\r\n        functionValues.push(fMin);\r\n    }\r\n    //step 3\r\n    for (let k = 0; k < K; k++) {\r\n        for (let j = 0; j < np; j++) {\r\n            let ni = getRandomInt(NImin, NImax + 1);//+1 because NImax should present.\r\n            let neighbors = new Set();\r\n            while (neighbors.size < ni) {\r\n                let idx = getRandomInt(0, np);\r\n                neighbors.add(population[idx]);\r\n            }\r\n            let minValueOfNeighbors = Number.MAX_SAFE_INTEGER;\r\n            let bestPositionOfNeighbors;\r\n            for (const c of neighbors) {\r\n                if (c.value < minValueOfNeighbors - EPS) {\r\n                    minValueOfNeighbors = c.value;\r\n                    bestPositionOfNeighbors = c.position;\r\n                }\r\n            }\r\n            //step 4\r\n            let c = population[j];\r\n            functionIterations += 2;\r\n            c.changePosition(bestPositionOfNeighbors);\r\n            let idxMin = getMinimum(population);\r\n            let xArr = population[idxMin].position;\r\n            let xMin = initializePoint(xArr);\r\n            let fMin = f.evaluate(xMin);\r\n            if (!arrayContainsIn(checkedPoints, xArr)) {\r\n                checkedPoints.push(xArr);\r\n                functionValues.push(fMin);\r\n            }\r\n        }\r\n    }\r\n    idxMin = getMinimum(population);\r\n    xArr = population[idxMin].position;\r\n    xMin = initializePoint(xArr);\r\n    fMin = f.evaluate(xMin);\r\n    if (!arrayContainsIn(checkedPoints, xArr)) {\r\n        checkedPoints.push(xArr);\r\n        functionValues.push(fMin);\r\n    }\r\n    return [checkedPoints, functionIterations, xMin, fMin, functionValues];\r\n}\r\nfunction tabuSearch(f, lb, ub, M, N, L,allowModification) {\r\n    let functionIterations = 0;\r\n    let maxEdge = Number.MIN_SAFE_INTEGER;\r\n    for (let i = 0; i < DIM; i++) {\r\n        let edge = ub[i] - lb[i];\r\n        if (edge - EPS > maxEdge) {\r\n            maxEdge = edge;\r\n        }\r\n    }\r\n    const delta = maxEdge;\r\n    const Rtr = delta / 100, Rstr = delta / 50;\r\n    const p = delta / 5;\r\n    const gamma = 0.25;\r\n    const L_ = 2 * DIM;\r\n    const Nmax = 1, Nmin = 1 / L;\r\n    const Mmax = 1, Mmin = 1 / L;\r\n    class TabuList {\r\n        constructor(arr) {\r\n            this.points = arr;\r\n            this.length = arr.length;\r\n        }\r\n        push(item) {\r\n            for (let i = 0; i < this.points.length; i++) {\r\n                this.points[i].Ir++;\r\n            }\r\n            this.points.push(item);\r\n            this.length++;\r\n            this.points.sort((a, b) => { return a.value - b.value });\r\n            for (let i = 1; i <= this.points.length; i++) {\r\n                this.points[i - 1].If = i;\r\n            }\r\n\r\n            for (let i = 0; i < this.points.length; i++) {\r\n                let item = this.points[i];\r\n                let Mr = Nmin + (Nmax - Nmin) * (L - item.Ir) / (L - 1);\r\n                if (item.If <= L_) {\r\n                    var Mf = Mmin + (Mmax - Mmin) * (L_ - item.If) / (L_ - 1);\r\n                }\r\n                else {\r\n                    var Mf = Mmin;\r\n                }\r\n                this.points[i].mValue = Math.max(Mr, Mf);\r\n            }\r\n        }\r\n        index(i) {\r\n            return this.points[i];\r\n        }\r\n        remove(index) {\r\n            let Ir_ = this.points[index].Ir; //8 out of 10\r\n            for (let i = 0; i < this.points.length; i++) {\r\n                if (this.points[i].Ir > Ir_) {\r\n                    this.points[i].Ir--;\r\n                }\r\n            }\r\n            this.points.splice(index, 1); //removing\r\n            this.length--;\r\n        }\r\n    }\r\n    class TabuPoint {\r\n        constructor(coordinate) {\r\n            this.coordinate = coordinate;\r\n            this.value = f.evaluate(initializePoint(coordinate));\r\n            this.Ir = 1;\r\n            this.If = 1;\r\n            this.mValue = 0;\r\n        }\r\n    }\r\n    class Region {\r\n        constructor(coordinate) {\r\n            this.coordinate = coordinate;\r\n            this.p = p;\r\n            this.phi = 1;\r\n        }\r\n    }\r\n\r\n    function getCentersOfTouchedSemiTabuRegions(tabuList, x, Rstr) {\r\n        let centers = [];\r\n        for (let i = 0; i < tabuList.length; i++) {\r\n            let t = tabuList.index(i).coordinate;\r\n            let lp = 0;\r\n            for (let j = 0; j < DIM; j++) {\r\n                lp += (x[j] - t[j]) ** 2;\r\n            }\r\n            if (lp < Rstr ** 2 - EPS) {\r\n                centers.push(t);\r\n            }\r\n        }\r\n        return centers;\r\n    }\r\n    function getMaxDistance(x, t) {\r\n        let Dmax = Number.MIN_SAFE_INTEGER;\r\n        for (let i = 0; i < t.length; i++) {\r\n            let r = math.norm(math.subtract(x, t[i]));\r\n            if (r > Dmax) {\r\n                Dmax = r;\r\n            }\r\n        }\r\n        return Dmax;\r\n    }\r\n    function getDirection(x, t_) {\r\n        let d = new Array(DIM);\r\n        for (let i = 0; i < DIM; i++) {\r\n            d[i] = Math.sign(x[i] - t_[i]);\r\n        }\r\n        return d;\r\n    }\r\n    function getStep(delta, Dmax, Rtr) {\r\n        let delta_ = new Array(DIM);\r\n        for (let i = 0; i < DIM; i++) {\r\n            let r = Math.random();\r\n            if (r === 0) {\r\n                r = EPS;\r\n            }\r\n            delta_[i] = delta * (1 + r) / 10;\r\n            if (delta_[i] < Dmax + Rtr) {\r\n                delta_[i] += Rtr;\r\n                if (delta_[i] < Dmax + Rtr) {\r\n                    delta_[i] += Dmax;\r\n                }\r\n            }\r\n        }\r\n        return delta_;\r\n    }\r\n    function adaptiveSearch(x, y, delta) {\r\n        let sumOfDeltaF = 0;\r\n        let fx = f.evaluate(initializePoint(x));\r\n        let w = new Array(DIM), u = new Array(DIM), v = new Array(DIM);\r\n        for (let i = 0; i < DIM; i++) {\r\n            v[i] = 0;\r\n        }\r\n        for (let i = 0; i < DIM; i++) {\r\n            let df = f.evaluate(initializePoint(y[i])) - fx;\r\n            functionIterations++;\r\n            w[i] = df;\r\n            sumOfDeltaF += df;\r\n        }\r\n        for (let i = 0; i < DIM; i++) {\r\n            w[i] /= sumOfDeltaF;\r\n            let a = math.subtract(y[i], x);\r\n            let zer = math.zeros(DIM);\r\n            let uNum = math.subtract(zer, a);\r\n            let uDen = math.norm(a);\r\n            u[i] = math.divide(uNum, uDen);\r\n            v = math.add(v, math.multiply(w[i], u[i]));\r\n        }\r\n        for (let i = 0; i < 2; i++) {\r\n            let sigma = Math.random() + i;\r\n            if (sigma === i) { sigma = EPS; }\r\n            let alpha = sigma * delta / 10;\r\n            let rp = math.multiply(alpha, math.divide(v, math.norm(v)));\r\n            let newPoint = math.add(x, rp);\r\n            for (let i = 0; i < DIM; i++) {\r\n                if (newPoint._data[i] > ub[i]) {\r\n                    newPoint._data[i] = ub[i];\r\n                }\r\n                else {\r\n                    if (newPoint._data[i] < lb[i]) {\r\n                        newPoint._data[i] = lb[i];\r\n                    }\r\n                }\r\n            }\r\n            y.push(newPoint._data);\r\n        }\r\n        let fMin = Number.MAX_SAFE_INTEGER;\r\n        for (let i = 0; i < y.length; i++) {\r\n            functionIterations++;\r\n            let fy = f.evaluate(initializePoint(y[i]));\r\n            if (fy < fMin) {\r\n                fMin = fy;\r\n                var xNext = y[i];\r\n            }\r\n        }\r\n        return xNext;\r\n    }\r\n    function updateTabuList(xNext, tabuList, L) {\r\n        let tabuPoint = new TabuPoint(xNext);\r\n        functionIterations++;\r\n        if (tabuList.length < L) {\r\n            tabuList.push(tabuPoint);\r\n        }\r\n        else {\r\n            let minValue = Number.MAX_SAFE_INTEGER;\r\n            let idxMin;\r\n            for (let i = 0; i < tabuList.length; i++) {\r\n                if (tabuList.index(i).mValue < minValue) {\r\n                    minValue = tabuList.index(i).mValue;\r\n                    idxMin = i;\r\n                }\r\n            }\r\n            tabuList.remove(idxMin);\r\n            tabuList.push(tabuPoint);\r\n        }\r\n    }\r\n    function updateVisitedRegionList(xNext, visitedRegionList) {\r\n        let isRegionTouched = false;\r\n        for (let i = 0; i < visitedRegionList.length; i++) {\r\n            let t = visitedRegionList[i].coordinate;\r\n            let lp = 0;\r\n            for (let j = 0; j < DIM; j++) {\r\n                lp += (xNext[j] - t[j]) ** 2;\r\n            }\r\n            if (lp < visitedRegionList[i].p ** 2 - EPS) {\r\n                visitedRegionList[i].phi++;\r\n                isRegionTouched = true;\r\n            }\r\n        }\r\n        if (!isRegionTouched) {\r\n            let newRegion = new Region(xNext);\r\n            visitedRegionList.push(newRegion);\r\n        }\r\n    }\r\n    let tabuList = new TabuList([]);\r\n    let visitedRegionList = [], checkedPoints = [], functionValues = [];\r\n    let x = new Array(DIM);\r\n    for (let i = 0; i < DIM; i++) {\r\n        x[i] = Math.random() * (ub[i] - lb[i]) + lb[i];\r\n    }\r\n    for (let j = 0; j < N; j++) {\r\n        //step 2.1 исследовательский поиск\r\n        for (let k = 0; k < M; k++) {\r\n            //step 2.1.1\r\n            checkedPoints.push(x);\r\n            functionValues.push(f.evaluate(initializePoint(x)));\r\n            let t = getCentersOfTouchedSemiTabuRegions(tabuList, x, Rstr);\r\n            let v = t.length;\r\n            if (v !== 0) {\r\n                let sum = new Array(DIM), t_ = new Array(DIM);\r\n                for (let i = 0; i < DIM; i++) {\r\n                    sum[i] = 0;\r\n                    t_[i] = 0;\r\n                }\r\n                for (let i = 0; i < t.length; i++) {\r\n                    sum = math.add(sum, t[i]);\r\n                }\r\n                t_ = math.divide(sum, v);\r\n                var Dmax = getMaxDistance(x, t);\r\n                var directionVector = getDirection(x, t_);\r\n            }\r\n            else {\r\n                var directionVector = new Array(DIM);\r\n                for (let i = 0; i < DIM; i++) {\r\n                    let coin = Math.random();\r\n                    if (coin > 0.5) {\r\n                        directionVector[i] = 1;\r\n                    }\r\n                    else {\r\n                        directionVector[i] = -1;\r\n                    }\r\n                }\r\n                var Dmax = 0;\r\n            }\r\n            //step 2.1.2\r\n            let delta_ = getStep(delta, Dmax, Rtr);\r\n            //step 2.1.3\r\n            var y = new Array(DIM);\r\n            let fxNext = Number.MAX_SAFE_INTEGER;\r\n            var xNext = Object.values(x).slice(0, DIM);\r\n            for (let i = 0; i < DIM; i++) {\r\n                y[i] = new Array(DIM);\r\n                for (let j = 0; j < DIM; j++) {\r\n                    y[i][j] = x[j];\r\n                }\r\n                y[i][i] += delta_[i] * directionVector[i];\r\n                if (y[i][i] > ub[i]) {\r\n                    y[i][i] = ub[i];\r\n                }\r\n                else {\r\n                    if (y[i][i] < lb[i]) {\r\n                        y[i][i] = lb[i];\r\n                    }\r\n                }\r\n                functionIterations++;\r\n                let fy = f.evaluate(initializePoint(y[i]));\r\n                if (fy < fxNext) {\r\n                    fxNext = fy;\r\n                    xNext = y[i];\r\n                }\r\n            }\r\n            //step 2.1.4\r\n            functionIterations++;\r\n            if (!(fxNext < f.evaluate(initializePoint(x)))) {\r\n                if (allowModification===true){\r\n                    //t0,iters,c,beta\r\n                    let returned=simulatedAnnealing(5,50,x,f,0.85,0.96,lb,ub);\r\n                    functionIterations+=returned[1];\r\n                    xNext=Object.values(returned[2]).slice(0, DIM);\r\n                }\r\n                else{\r\n                    xNext = adaptiveSearch(x, y, delta);\r\n                }\r\n            }\r\n            //step 2.1.5\r\n            updateTabuList(x, tabuList, L);\r\n            updateVisitedRegionList(x, visitedRegionList);\r\n            x = xNext;\r\n        }\r\n        //step 2.2 перераспределительный поиск\r\n        masterLoop: for (; ;) {\r\n            var z = new Array(DIM);\r\n            for (let i = 0; i < DIM; i++) {\r\n                z[i] = Math.random() * (ub[i] - lb[i]) + lb[i];\r\n            }\r\n            for (let i = 0; i < visitedRegionList.length; i++) {\r\n                let r = visitedRegionList[i];\r\n                let Phi = gamma * (1 - Math.exp(-gamma * (r.phi - 1)));\r\n                let s = (1 + Phi) * math.norm(math.subtract(r.coordinate, z));\r\n                if (s / p < 1) {\r\n                    continue masterLoop;\r\n                }\r\n            }\r\n            break masterLoop;\r\n        }\r\n        x = z;\r\n    }\r\n    //step 3 интенсивно-уточняющий поиск\r\n    let eps = 0.2, deltaVector = [1, 1], lambda = 1, alpha = 1.2;\r\n    let fMin = Number.MAX_SAFE_INTEGER;\r\n    for (let i = 0; i < L_; i++) {\r\n        let startPoint = tabuList.index(i).coordinate;\r\n        let returnedFromMethod = hookeJeeves(startPoint, f, eps, deltaVector, lambda, alpha, lb, ub);\r\n        functionIterations += returnedFromMethod[1];\r\n        let returnedfMin = returnedFromMethod[3];\r\n        if (returnedfMin < fMin) {\r\n            fMin = returnedfMin;\r\n            var xMin = returnedFromMethod[2];\r\n            checkedPoints.push(Object.values(xMin).slice(0, DIM));\r\n            functionValues.push(fMin);\r\n        }\r\n    }\r\n    return [checkedPoints, functionIterations, xMin, fMin, functionValues];\r\n}\r\nfunction startOptimization(selectedMethodString, params) {\r\n    let objectiveFunctionString = params.objectiveFunction;\r\n    /*if (params.Aeq !== undefined || params.Beq !== undefined){\r\n        var Aeq=params.Aeq;\r\n        var Beq=params.Beq;\r\n    }*/\r\n    let re = /[\\w.-]+/g;\r\n    let lowerBound = params.lowerBound.match(re);\r\n    let upperBound = params.upperBound.match(re);\r\n    \r\n    DIM = lowerBound.length;\r\n    for (let i = 0; i < DIM; i++) {\r\n        lowerBound[i] = parseFloat(lowerBound[i]);\r\n        upperBound[i] = parseFloat(upperBound[i]);\r\n        if (isNaN(lowerBound[i])) {\r\n            lowerBound[i] = Number.MIN_SAFE_INTEGER;\r\n        }\r\n        if (isNaN(upperBound[i])) {\r\n            upperBound[i] = Number.MAX_SAFE_INTEGER;\r\n        }\r\n    }\r\n\r\n    let objectiveFunction = parseFunction(objectiveFunctionString, DIM);\r\n    if (objectiveFunction === -1) {\r\n        return -1;\r\n    }\r\n    \r\n    switch (selectedMethodString) {\r\n        case \"HJ\": {\r\n            if (CheckStringVector(params.startPoint)!==0){\r\n                return -2;\r\n            }\r\n            let startPoint = parseStartPoint(params.startPoint,lowerBound,upperBound);\r\n\r\n            if (startPoint === -2) {\r\n                return -2;\r\n            }\r\n            let eps = parseFloat(params.eps);\r\n            let alpha = parseFloat(params.alpha);\r\n            let lambda = parseFloat(params.lambda);\r\n            let deltaVector = params.deltaVector.match(/[\\d.]+/g);\r\n            for (let i = 0; i < deltaVector.length; i++) {\r\n                deltaVector[i] = parseFloat(deltaVector[i]);\r\n            }\r\n\r\n            \r\n            \r\n            var start=Date.now();\r\n            var returnedFromMethod = hookeJeeves(startPoint, objectiveFunction, eps, deltaVector, lambda, alpha, lowerBound, upperBound);\r\n            var methodTime=Date.now()-start;\r\n            break;\r\n        }\r\n        case \"SA\": {\r\n            if (CheckStringVector(params.startPoint)!==0){\r\n                return -2;\r\n            }\r\n            let startPoint = parseStartPoint(params.startPoint,lowerBound,upperBound);\r\n            if (startPoint === -2) {\r\n                return -2;\r\n            }\r\n            let maxIter = parseInt(params.maxIterations);\r\n            let startT = parseFloat(params.initialTemperature);\r\n            let c = parseFloat(params.c);\r\n            let beta = parseFloat(params.beta);\r\n            \r\n            \r\n            var start=Date.now();\r\n            var returnedFromMethod = simulatedAnnealing(startT, maxIter, startPoint, objectiveFunction, c, beta, lowerBound, upperBound);\r\n            var methodTime=Date.now()-start;\r\n            break;\r\n        }\r\n        case \"Genetic\": {\r\n            let tMax = parseInt(params.maxIterations), m = parseInt(params.m), li = parseInt(params.li);\r\n            var start=Date.now();\r\n            var returnedFromMethod = geneticBinary(tMax, m, objectiveFunction, lowerBound, upperBound, li);\r\n            var methodTime=Date.now()-start;\r\n            break;\r\n        }\r\n        case \"Swarm\": {\r\n            let maxIter = parseInt(params.maxIterations);\r\n            let np = parseInt(params.np);\r\n            let ni = params.ni.match(/[\\d.]+/g);\r\n            for (let i = 0; i < ni.length; i++) {\r\n                ni[i] = parseInt(ni[i]);\r\n            }\r\n            let omega = parseFloat(params.omega);\r\n            let alpha = parseFloat(params.alpha);\r\n            let beta = parseFloat(params.beta);\r\n            var start=Date.now();\r\n            var returnedFromMethod = particleSwarm(objectiveFunction, lowerBound, upperBound,\r\n                maxIter, np, ni, omega, alpha, beta);\r\n            var methodTime=Date.now()-start;\r\n            break;\r\n        }\r\n        case \"Tabu\": {\r\n            let M = parseInt(params.M), N = parseInt(params.N), L = parseInt(params.L);\r\n            let allowModification=params.mod;\r\n            if (allowModification === undefined){\r\n                allowModification=false;\r\n            }\r\n            var start=Date.now();\r\n            var returnedFromMethod = tabuSearch(objectiveFunction, lowerBound, upperBound,\r\n                M, N, L,allowModification);\r\n            var methodTime=Date.now()-start;\r\n            break;\r\n        }\r\n        // no default\r\n    }\r\n    let checkedPoints, functionIterations, xMin, fMin, functionValues;\r\n    checkedPoints = returnedFromMethod[0];\r\n    functionIterations = returnedFromMethod[1];\r\n    xMin = returnedFromMethod[2];\r\n    fMin = returnedFromMethod[3];\r\n    functionValues = returnedFromMethod[4];\r\n    let data = [checkedPoints, functionIterations, xMin, fMin, DIM, functionValues,methodTime];\r\n    if (DIM <= 2) {\r\n        let [X, Y, checkedPointsT, labelsList] = getValuesForPlot(objectiveFunction, lowerBound, upperBound, checkedPoints);\r\n        data.push(X, Y, checkedPointsT, labelsList);\r\n    }\r\n    return data;\r\n}\r\nexport { startOptimization, CheckStringVector };","function getPlot(X, Z, labelsList, checkedPoints, xMin,fMin,DIM) {\r\n    let scatterData = {\r\n        x: checkedPoints[0],\r\n        y: checkedPoints[1],\r\n        type: \"scatter\",\r\n        line: { color: \"red\" },\r\n        text: labelsList,\r\n        textposition: \"top center\",\r\n        mode: \"lines+markers+text\",\r\n        textfont: { color: \"white\" },\r\n        hoverinfo: \"x+y+z\",\r\n        name: \"Линия поиска\"\r\n    };\r\n    \r\n    switch (DIM) {\r\n        case 1:\r\n            var contourData = {\r\n                x: X[0],\r\n                y: Z,\r\n                type: \"scatter\",\r\n                line: { color: \"black\" },\r\n                hoverinfo: \"x+y\",\r\n                name: \"Целевая функция\"\r\n            };\r\n            var scatterMinData = {\r\n                x: [xMin.x1],\r\n                y: [fMin],\r\n                type: \"scatter\",\r\n                line: { color: \"Green\" },\r\n                marker: { symbol:\"diamond\",size:10 },\r\n                hoverinfo: \"x+y+z\",\r\n                name: \"x*\"\r\n            };\r\n            break;\r\n        case 2:\r\n            var contourData = {\r\n                x: X[0],\r\n                y: X[1],\r\n                z: Z,\r\n                type: \"contour\",\r\n                contours: { start: -900, end: 600, size: 20 },\r\n                name: \"Линии уровня\"\r\n            };\r\n            var scatterMinData = {\r\n                x: [xMin.x1],\r\n                y: [xMin.x2],\r\n                type: \"scatter\",\r\n                line: { color: \"Green\" },\r\n                marker: { symbol:\"diamond\",size:10 },\r\n                hoverinfo: \"x+y+z\",\r\n                name: \"x*\"\r\n            };\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n    let data = [scatterData,scatterMinData, contourData];\r\n\r\n    let layout = {\r\n        margin: { t: 10 },\r\n        hovermode: \"closest\",\r\n        showlegend: false\r\n    };\r\n    return [data,layout];\r\n}\r\n\r\nexport default getPlot;","import { useState } from \"react\";\nimport Options from \"./components/Options\"\nimport InputRow from \"./components/InputRow\";\nimport { startOptimization, CheckStringVector } from \"./modules/main\";\nimport getPlot from \"./modules/plot\"\nimport createPlotlyComponent from 'react-plotly.js/factory'\nimport Plotly from 'plotly.js-cartesian-dist'\nimport { BrowserView } from 'react-device-detect';\nimport \"./App.css\"\nvar parametersList = [];\n\nconst Plot = createPlotlyComponent(Plotly);\nconst rowsData = [\n  { id: \"objectiveFunction\", name: \"Целевая функция\", required: \"required\", pattern: \"[a-zA-Z0-9 +/.*^()-]+\" },\n  { id: \"lowerBound\", name: \"Нижняя граница\", required: \"required\", pattern: \"[pie\\\\d .,;\\\\[\\\\]-]+\" },\n  { id: \"upperBound\", name: \"Верхняя граница\", required: \"required\", pattern: \"[pie\\\\d .,;\\\\[\\\\]-]+\" }\n];\n\nconst methodFullName=[];\nmethodFullName[\"HJ\"]=\"Метод Хука-Дживса\";\nmethodFullName[\"Swarm\"]=\"Метод частиц в стае\";\nmethodFullName[\"SA\"]=\"Метод имитации отжига\";\nmethodFullName[\"Genetic\"]=\"Генетический алгоритм\";\nmethodFullName[\"Tabu\"]=\"Метод табу-поиска\";\nfunction App() {\n  var [plotState, setPlotState] = useState({\n    data: [],\n    layout: {}\n  });\n  var [results, setResults] = useState('');\n  var [method, setMethod] = useState(\"HJ\");\n  const inputRowList = rowsData.map(row =>\n    <InputRow key={row.id} id={row.id} name={row.name} pattern={row.pattern} sendData={sendData} required={row.required} />);\n\n  function sendData(id, value) {\n    parametersList[id] = value;\n  }\n\n  function onSubmit(e) {\n    e.preventDefault();\n    if (CheckStringVector(parametersList[\"lowerBound\"])!==0){\n      alert(\"Error while parsing the lower bound\");\n      return;\n    }\n    if (CheckStringVector(parametersList[\"upperBound\"])!==0){\n      alert(\"Error while parsing the upper bound\");\n        return;\n    }\n    var returnedFromMethod = startOptimization(method, parametersList);\n    if (returnedFromMethod === -1){\n      alert(\"Error while parsing the function\");\n      return;\n    }\n    else{\n      if (returnedFromMethod===-2){\n        alert(\"Error while parsing the start point\");\n        return;\n      }\n    }\n    let checkedPoints = returnedFromMethod[0],\n      functionIterations = returnedFromMethod[1],\n      xMin = returnedFromMethod[2],\n      fMin = returnedFromMethod[3],\n      DIM = returnedFromMethod[4];\n    let functionValues = returnedFromMethod[5];\n    let methodTime = returnedFromMethod[6]/1000;\n    if (DIM <= 2) {\n      let X = returnedFromMethod[7],\n        Y = returnedFromMethod[8],\n        checkedPointsT = returnedFromMethod[9],\n        labelsList = returnedFromMethod[10];\n      let plotData = getPlot(X, Y, labelsList, checkedPointsT, xMin, fMin, DIM);\n      var newPlotState = {\n        data: plotData[0],\n        layout: plotData[1]\n      };\n    }\n    else {\n      var newPlotState = {\n        data: [],\n        layout: {}\n      };\n    }\n    //<textarea> filling\n    let s = \"\";\n    for (let i = 0; i < checkedPoints.length; i++) {\n      let stringVector = \"\";\n      for (const item of checkedPoints[i]) {\n        stringVector += item.toFixed(4) + ',';\n      }\n      stringVector = stringVector.slice(0, -2);//remove the last comma\n      s = s + i + ': (' + stringVector + '). ' + 'f=' + functionValues[i].toFixed(4) + '\\n';\n    }\n    let stringMinVector = \"\";\n    let j = 1;\n    for (const i in xMin) {\n      stringMinVector += xMin[i].toFixed(4) + ',';\n      if (j === DIM) {\n        break;\n      }\n      j++;\n    }\n    stringMinVector = stringMinVector.slice(0, -2);\n    let newResults = `${results}\\n${methodFullName[method]}\\n${s}x*=(${stringMinVector}), f(x*)=${fMin.toFixed(4)}\\nВычислений целевой функции ${functionIterations}. Время: ${methodTime} сек.\\n------`;\n    \n    setPlotState(newPlotState);\n    setResults(newResults);\n  }\n\n  return (\n    <div className=\"App\">\n      <div className=\"main section\">\n        <div className=\"solver section\">\n          <label htmlFor=\"solver\">Выберите метод:</label>\n          <select id=\"solver\">\n            <option onClick={() => setMethod(\"HJ\")}>{methodFullName[\"HJ\"]}</option>\n            <option onClick={() => setMethod(\"SA\")}>{methodFullName[\"SA\"]}</option>\n            <option onClick={() => setMethod(\"Genetic\")}>{methodFullName[\"Genetic\"]}</option>\n            <option onClick={() => setMethod(\"Swarm\")}>{methodFullName[\"Swarm\"]}</option>\n            <option onClick={() => setMethod(\"Tabu\")}>{methodFullName[\"Tabu\"]}</option>\n          </select>\n        </div>\n        <form onSubmit={onSubmit}>\n        <div className=\"problem section\">\n          {inputRowList}\n        </div>\n        <Options method={method} sendData={sendData} />\n        \n          <div className=\"btn-submit section\">\n            <button id=\"btn-submit\">Старт</button>\n          </div>\n        </form>\n        <BrowserView>\n          <div className=\"plot section\">\n            <Plot data={plotState.data} layout={plotState.layout}\n              onInitialized={(figure) => setPlotState(figure)}\n              onUpdate={(figure) => setPlotState(figure)} />\n          </div>\n        </BrowserView>\n\n      </div>\n\n      <div className=\"results section\">\n        <textarea className=\"tbox\" readOnly value={results}>\n        </textarea>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}